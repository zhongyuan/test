<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gaia::core::SurfaceHolder Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = '../../open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = '../../closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d9/db5/namespacegaia.html">gaia</a>      </li>
      <li class="navelem"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">gaia::core::SurfaceHolder Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="gaia::core::SurfaceHolder" -->
<p><code>#include &lt;<a class="el" href="../../df/da8/_surface_holder_8h_source.html">SurfaceHolder.h</a>&gt;</code></p>

<p><a href="../../dc/d59/classgaia_1_1core_1_1_surface_holder-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5">SurfaceType</a> { <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5aec1ba8425b5d50dd30aef79320c1a257">SURFACE_TYPE_NORMAL</a> =  0, 
<a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5ac9796cce522329845e4188b6309d113d">SURFACE_TYPE_HARDWARE</a> =  1, 
<a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5ab7e2c0fc0602dc37857e051fcafc688f">SURFACE_TYPE_GPU</a> =  2, 
<a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5a44d1fe0964ef3edf53673e76315d25b1">SURFACE_TYPE_PUSH_BUFFERS</a> =  3
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a6c37ef749ab14d5520fc8284090fb473">SurfaceHolder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a2fa482955f6482ffd74b9544f2740e26">SurfaceHolder</a> (const <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a> &amp;surfaceHolder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a1f1b72fce682fd5df327aaeb82dcc511">~SurfaceHolder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#ad331c27da39398cebf633736d380b780">addCallback</a> (const <a class="el" href="../../d0/da2/classgaia_1_1core_1_1_surface_holder_callback.html">SurfaceHolderCallback</a> &amp;callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a Callback interface for this holder.  <a href="#ad331c27da39398cebf633736d380b780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a671e4902b806fa79a192d6dccab2d295">removeCallback</a> (const <a class="el" href="../../d0/da2/classgaia_1_1core_1_1_surface_holder_callback.html">SurfaceHolderCallback</a> &amp;callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added Callback interface from this holder.  <a href="#a671e4902b806fa79a192d6dccab2d295"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#ae6961ca58d27c641b42497dc5558b5f4">isCreating</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to find out if the surface is in the process of being created from Callback methods.  <a href="#ae6961ca58d27c641b42497dc5558b5f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a7575da74f043fef68b24e77fc4466c66">setType</a> (<a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5">SurfaceHolder::SurfaceType</a> type) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface's type.  <a href="#a7575da74f043fef68b24e77fc4466c66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#af426ab30fb8f47024fd5dd2fdf6d54ad">setFixedSize</a> (int32_t width, int32_t height) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the surface a fixed size.  <a href="#af426ab30fb8f47024fd5dd2fdf6d54ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a9873e5c571bfe7a6469ebc4ac5221152">setSizeFromLayout</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the surface to resized based on layout of its container (this is the default).  <a href="#a9873e5c571bfe7a6469ebc4ac5221152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#aa626e346d911b69e7dffa86c622b8ad9">setFormat</a> (<a class="el" href="../../d5/dea/classgaia_1_1graphics_1_1_pixel_format.html#a0eeb310c054cb38c1cd7e2a645a77b3e">gaia::graphics::PixelFormat::Format</a> format) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the desired PixelFormat of the surface.  <a href="#aa626e346d911b69e7dffa86c622b8ad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#aba57c6ec758914929bb86d4fd3691006">setKeepScreenOn</a> (bool screenOn) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable option to keep the screen turned on while this surface is displayed.  <a href="#aba57c6ec758914929bb86d4fd3691006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d1/dc5/classgaia_1_1graphics_1_1_canvas.html">gaia::graphics::Canvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5">lockCanvasN</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start editing the pixels in the surface.  <a href="#a5a3a34c75787acf8a547f05f642e60c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d1/dc5/classgaia_1_1graphics_1_1_canvas.html">gaia::graphics::Canvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a1c73aff1161457520ca136f754ae4a7b">lockCanvasN</a> (const <a class="el" href="../../d5/d65/classgaia_1_1graphics_1_1_rect.html">gaia::graphics::Rect</a> &amp;dirty) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5">lockCanvasN()</a> but allows specification of a dirty rectangle.  <a href="#a1c73aff1161457520ca136f754ae4a7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a9c4dffc7ad03527be41c978c38adad35">unlockCanvasAndPost</a> (const <a class="el" href="../../d1/dc5/classgaia_1_1graphics_1_1_canvas.html">gaia::graphics::Canvas</a> &amp;canvas) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish editing pixels in the surface.  <a href="#a9c4dffc7ad03527be41c978c38adad35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d5/d65/classgaia_1_1graphics_1_1_rect.html">gaia::graphics::Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#afb3b4e8176cd5f18d829e221344b87aa">getSurfaceFrame</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current size of the surface.  <a href="#afb3b4e8176cd5f18d829e221344b87aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#aeda359566cc63b587ebfe1ae4c5a4999">getNativeWindow</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a94e1af3a46fd20411deda82c39c90153">operator=</a> (const <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a> &amp;other)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="../../df/da8/_surface_holder_8h_source.html#l00018">18</a> of file <a class="el" href="../../df/da8/_surface_holder_8h_source.html">SurfaceHolder.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a92782b6f8796f6b420e5e5b37baea9f5"></a><!-- doxytag: member="gaia::core::SurfaceHolder::SurfaceType" ref="a92782b6f8796f6b420e5e5b37baea9f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5">gaia::core::SurfaceHolder::SurfaceType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a92782b6f8796f6b420e5e5b37baea9f5aec1ba8425b5d50dd30aef79320c1a257"></a><!-- doxytag: member="SURFACE_TYPE_NORMAL" ref="a92782b6f8796f6b420e5e5b37baea9f5aec1ba8425b5d50dd30aef79320c1a257" args="" -->SURFACE_TYPE_NORMAL</em>&nbsp;</td><td>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>this is ignored, this value is set automatically when needed.</dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92782b6f8796f6b420e5e5b37baea9f5ac9796cce522329845e4188b6309d113d"></a><!-- doxytag: member="SURFACE_TYPE_HARDWARE" ref="a92782b6f8796f6b420e5e5b37baea9f5ac9796cce522329845e4188b6309d113d" args="" -->SURFACE_TYPE_HARDWARE</em>&nbsp;</td><td>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>this is ignored, this value is set automatically when needed.</dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92782b6f8796f6b420e5e5b37baea9f5ab7e2c0fc0602dc37857e051fcafc688f"></a><!-- doxytag: member="SURFACE_TYPE_GPU" ref="a92782b6f8796f6b420e5e5b37baea9f5ab7e2c0fc0602dc37857e051fcafc688f" args="" -->SURFACE_TYPE_GPU</em>&nbsp;</td><td>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>this is ignored, this value is set automatically when needed.</dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a92782b6f8796f6b420e5e5b37baea9f5a44d1fe0964ef3edf53673e76315d25b1"></a><!-- doxytag: member="SURFACE_TYPE_PUSH_BUFFERS" ref="a92782b6f8796f6b420e5e5b37baea9f5a44d1fe0964ef3edf53673e76315d25b1" args="" -->SURFACE_TYPE_PUSH_BUFFERS</em>&nbsp;</td><td>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>this is ignored, this value is set automatically when needed.</dd></dl>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="../../df/da8/_surface_holder_8h_source.html#l00020">20</a> of file <a class="el" href="../../df/da8/_surface_holder_8h_source.html">SurfaceHolder.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6c37ef749ab14d5520fc8284090fb473"></a><!-- doxytag: member="gaia::core::SurfaceHolder::SurfaceHolder" ref="a6c37ef749ab14d5520fc8284090fb473" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gaia::core::SurfaceHolder::SurfaceHolder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fa482955f6482ffd74b9544f2740e26"></a><!-- doxytag: member="gaia::core::SurfaceHolder::SurfaceHolder" ref="a2fa482955f6482ffd74b9544f2740e26" args="(const SurfaceHolder &amp;surfaceHolder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gaia::core::SurfaceHolder::SurfaceHolder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a> &amp;&#160;</td>
          <td class="paramname"><em>surfaceHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f1b72fce682fd5df327aaeb82dcc511"></a><!-- doxytag: member="gaia::core::SurfaceHolder::~SurfaceHolder" ref="a1f1b72fce682fd5df327aaeb82dcc511" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual gaia::core::SurfaceHolder::~SurfaceHolder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad331c27da39398cebf633736d380b780"></a><!-- doxytag: member="gaia::core::SurfaceHolder::addCallback" ref="ad331c27da39398cebf633736d380b780" args="(const SurfaceHolderCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::addCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da2/classgaia_1_1core_1_1_surface_holder_callback.html">SurfaceHolderCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a Callback interface for this holder. </p>
<p>There can several Callback interfaces associated with a holder.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The new Callback interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeda359566cc63b587ebfe1ae4c5a4999"></a><!-- doxytag: member="gaia::core::SurfaceHolder::getNativeWindow" ref="aeda359566cc63b587ebfe1ae4c5a4999" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* gaia::core::SurfaceHolder::getNativeWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb3b4e8176cd5f18d829e221344b87aa"></a><!-- doxytag: member="gaia::core::SurfaceHolder::getSurfaceFrame" ref="afb3b4e8176cd5f18d829e221344b87aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d5/d65/classgaia_1_1graphics_1_1_rect.html">gaia::graphics::Rect</a> gaia::core::SurfaceHolder::getSurfaceFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current size of the surface. </p>
<p>Note: do not modify the returned Rect. This is only safe to call from the thread of <a class="el" href="../../">SurfaceView</a>'s window, or while inside of <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5">lockCanvasN()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rect The surface's dimensions. The left and top are always 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6961ca58d27c641b42497dc5558b5f4"></a><!-- doxytag: member="gaia::core::SurfaceHolder::isCreating" ref="ae6961ca58d27c641b42497dc5558b5f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gaia::core::SurfaceHolder::isCreating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this method to find out if the surface is in the process of being created from Callback methods. </p>
<p>This is intended to be used with <a class="el" href="../../">Callback#surfaceChanged</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the surface is in the process of being created. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a3a34c75787acf8a547f05f642e60c5"></a><!-- doxytag: member="gaia::core::SurfaceHolder::lockCanvasN" ref="a5a3a34c75787acf8a547f05f642e60c5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d1/dc5/classgaia_1_1graphics_1_1_canvas.html">gaia::graphics::Canvas</a>* gaia::core::SurfaceHolder::lockCanvasN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start editing the pixels in the surface. </p>
<p>The returned Canvas can be used to draw into the surface's bitmap. A null is returned if the surface has not been created or otherwise cannot be edited. You will usually need to implement <a class="el" href="../../">Callback.surfaceCreated</a> to find out when the Surface is available for use.</p>
<p>The content of the Surface is never preserved between unlockCanvas() and <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5" title="Start editing the pixels in the surface.">lockCanvasN()</a>, for this reason, every pixel within the Surface area must be written. The only exception to this rule is when a dirty rectangle is specified, in which case, non-dirty pixels will be preserved.</p>
<p>If you call this repeatedly when the Surface is not ready (before <a class="el" href="../../">Callback.surfaceCreated</a> or after <a class="el" href="../../">Callback.surfaceDestroyed</a>), your calls will be throttled to a slow rate in order to avoid consuming CPU.</p>
<p>If null is not returned, this function internally holds a lock until the corresponding <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a9c4dffc7ad03527be41c978c38adad35">unlockCanvasAndPost</a> call, preventing <a class="el" href="../../">SurfaceView</a> from creating, destroying, or modifying the surface while it is being drawn. This can be more convenient than accessing the Surface directly, as you do not need to do special synchronization with a drawing thread in <a class="el" href="../../">Callback.surfaceDestroyed</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Canvas Use to draw into the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c73aff1161457520ca136f754ae4a7b"></a><!-- doxytag: member="gaia::core::SurfaceHolder::lockCanvasN" ref="a1c73aff1161457520ca136f754ae4a7b" args="(const gaia::graphics::Rect &amp;dirty) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d1/dc5/classgaia_1_1graphics_1_1_canvas.html">gaia::graphics::Canvas</a>* gaia::core::SurfaceHolder::lockCanvasN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d65/classgaia_1_1graphics_1_1_rect.html">gaia::graphics::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>dirty</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Just like <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5">lockCanvasN()</a> but allows specification of a dirty rectangle. </p>
<p>Every pixel within that rectangle must be written; however pixels outside the dirty rectangle will be preserved by the next call to <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5" title="Start editing the pixels in the surface.">lockCanvasN()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>gaia::view::SurfaceHolder::lockCanvas</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirty</td><td>Area of the Surface that will be modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Canvas Use to draw into the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a94e1af3a46fd20411deda82c39c90153"></a><!-- doxytag: member="gaia::core::SurfaceHolder::operator=" ref="a94e1af3a46fd20411deda82c39c90153" args="(const SurfaceHolder &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a>&amp; gaia::core::SurfaceHolder::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html">SurfaceHolder</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a671e4902b806fa79a192d6dccab2d295"></a><!-- doxytag: member="gaia::core::SurfaceHolder::removeCallback" ref="a671e4902b806fa79a192d6dccab2d295" args="(const SurfaceHolderCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::removeCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da2/classgaia_1_1core_1_1_surface_holder_callback.html">SurfaceHolderCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a previously added Callback interface from this holder. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The Callback interface to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af426ab30fb8f47024fd5dd2fdf6d54ad"></a><!-- doxytag: member="gaia::core::SurfaceHolder::setFixedSize" ref="af426ab30fb8f47024fd5dd2fdf6d54ad" args="(int32_t width, int32_t height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::setFixedSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make the surface a fixed size. </p>
<p>It will never change from this size. When working with a {link SurfaceView}, this must be called from the same thread running the SurfaceView's window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The surface's width. </td></tr>
    <tr><td class="paramname">height</td><td>The surface's height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa626e346d911b69e7dffa86c622b8ad9"></a><!-- doxytag: member="gaia::core::SurfaceHolder::setFormat" ref="aa626e346d911b69e7dffa86c622b8ad9" args="(gaia::graphics::PixelFormat::Format format) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::setFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/dea/classgaia_1_1graphics_1_1_pixel_format.html#a0eeb310c054cb38c1cd7e2a645a77b3e">gaia::graphics::PixelFormat::Format</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the desired PixelFormat of the surface. </p>
<p>The default is OPAQUE. When working with a {link SurfaceView}, this must be called from the same thread running the SurfaceView's window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A constant from PixelFormat.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/dea/classgaia_1_1graphics_1_1_pixel_format.html" title="Encode the format of display system.">gaia::graphics::PixelFormat</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aba57c6ec758914929bb86d4fd3691006"></a><!-- doxytag: member="gaia::core::SurfaceHolder::setKeepScreenOn" ref="aba57c6ec758914929bb86d4fd3691006" args="(bool screenOn) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::setKeepScreenOn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>screenOn</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable option to keep the screen turned on while this surface is displayed. </p>
<p>The default is false, allowing it to turn off. This is safe to call from any thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">screenOn</td><td>Set to true to force the screen to stay on, false to allow it to turn off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9873e5c571bfe7a6469ebc4ac5221152"></a><!-- doxytag: member="gaia::core::SurfaceHolder::setSizeFromLayout" ref="a9873e5c571bfe7a6469ebc4ac5221152" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::setSizeFromLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allow the surface to resized based on layout of its container (this is the default). </p>
<p>When this is enabled, you should monitor <a class="el" href="../../">Callback#surfaceChanged</a> for changes to the size of the surface. When working with a {link SurfaceView}, this must be called from the same thread running the SurfaceView's window. </p>

</div>
</div>
<a class="anchor" id="a7575da74f043fef68b24e77fc4466c66"></a><!-- doxytag: member="gaia::core::SurfaceHolder::setType" ref="a7575da74f043fef68b24e77fc4466c66" args="(SurfaceHolder::SurfaceType type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a92782b6f8796f6b420e5e5b37baea9f5">SurfaceHolder::SurfaceType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the surface's type. </p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>this is ignored, this value is set automatically when needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4dffc7ad03527be41c978c38adad35"></a><!-- doxytag: member="gaia::core::SurfaceHolder::unlockCanvasAndPost" ref="a9c4dffc7ad03527be41c978c38adad35" args="(const gaia::graphics::Canvas &amp;canvas) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::SurfaceHolder::unlockCanvasAndPost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/dc5/classgaia_1_1graphics_1_1_canvas.html">gaia::graphics::Canvas</a> &amp;&#160;</td>
          <td class="paramname"><em>canvas</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish editing pixels in the surface. </p>
<p>After this call, the surface's current pixels will be shown on the screen, but its content is lost, in particular there is no guarantee that the content of the Surface will remain unchanged when <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5" title="Start editing the pixels in the surface.">lockCanvasN()</a> is called again.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5" title="Start editing the pixels in the surface.">lockCanvasN()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td>The Canvas previously returned by <a class="el" href="../../da/da3/classgaia_1_1core_1_1_surface_holder.html#a5a3a34c75787acf8a547f05f642e60c5" title="Start editing the pixels in the surface.">lockCanvasN()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/gpdbuildserver3/Jenkins_Workspace/workspace/BuildGaia2SDKLauncher/sdk/include/gaia/core/<a class="el" href="../../df/da8/_surface_holder_8h_source.html">SurfaceHolder.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 12 2013 04:17:42 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
