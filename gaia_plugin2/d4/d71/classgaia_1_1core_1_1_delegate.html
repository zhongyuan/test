<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gaia::core::Delegate Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = '../../open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = '../../closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d9/db5/namespacegaia.html">gaia</a>      </li>
      <li class="navelem"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html">Delegate</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">gaia::core::Delegate Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="gaia::core::Delegate" -->
<p>The <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a> is for creating an extenal thread, in a process differs from a <a class="el" href="../../db/d3f/classgaia_1_1core_1_1_page.html" title="An page is a single, focused thing that the user can do.">Page</a> process, to process the long-term task.  
 <a href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d9/dfd/_delegate_8h_source.html">Delegate.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png"/> Inheritance diagram for gaia::core::Delegate:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>

<p><a href="../../d3/d71/classgaia_1_1core_1_1_delegate-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#adec18e573d22afa271f8f87c2d48a6b1">Delegate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To create the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>.  <a href="#adec18e573d22afa271f8f87c2d48a6b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a267429aa412fc3a85e2fd27117281c12">~Delegate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To destroy the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>.  <a href="#a267429aa412fc3a85e2fd27117281c12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a65bd46f422f886726101e4a744189464">renewPeriod</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renew the time slice.  <a href="#a65bd46f422f886726101e4a744189464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a24b686f200d32acb7ed3b5af1c1de41e">reignPeriod</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reign the time slice.  <a href="#a24b686f200d32acb7ed3b5af1c1de41e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a2bb4e0166d3f42eb5e3a1c19eebe6f5a">onLoad</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook represents that the delegate has been loaded into process.  <a href="#a2bb4e0166d3f42eb5e3a1c19eebe6f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca">onInvoke</a> (<a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *demand, int32_t flags, int32_t invokeId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is where you implement your asynchronously tasks.  <a href="#a4d1eb2a7b0751d35d9fdc29bca7d06ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470">onTimedout</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook is where you stop or pause your asynchronously tasks.  <a href="#a8e6d2c5d3a43a9ac50916c65545ff470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a7e82e97e59b73247fcd28bde3ecef2e4">onDismiss</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook represents that the delegate is going to be removed from process.  <a href="#a7e82e97e59b73247fcd28bde3ecef2e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#af3d8268be2891b030e1acc80c1eb904e">onConfigurationChanged</a> (<a class="el" href="../../de/df1/classgaia_1_1content_1_1_configuration.html">gaia::content::Configuration</a> *newConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the system when the device configuration changes while your page is running.  <a href="#af3d8268be2891b030e1acc80c1eb904e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a5c0e94bab09102d3f154931a76ea690d">onTrimMemory</a> (int32_t level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt.  <a href="#a5c0e94bab09102d3f154931a76ea690d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html">IBinder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a05f30a84eff2b60e1ed844265fe90632">onBind</a> (<a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *demand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the communication channel to the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>.  <a href="#a05f30a84eff2b60e1ed844265fe90632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a821f8c40c0a2299caf720671cab725a0">onUnbind</a> (<a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *demand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all clients have disconnected from a particular interface published by the delegate.  <a href="#a821f8c40c0a2299caf720671cab725a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a33ee05fc5c1f4b5068f3ab6904a0268e">onRebind</a> (<a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *demand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new clients have connected to the service, after it had previously been notified that all had disconnected in its <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a821f8c40c0a2299caf720671cab725a0">onUnbind</a>.  <a href="#a33ee05fc5c1f4b5068f3ab6904a0268e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8be459dd8c9ced1348dcf5c406a828c9">revokeSelf</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the delegate, if it was previously invoked.  <a href="#a8be459dd8c9ced1348dcf5c406a828c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a102f4eb11d46da93c94ead86e157eb68">revokeSelf</a> (int32_t invokeId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the delegate if the most recent time it was invoked was <em>invokeId</em>.  <a href="#a102f4eb11d46da93c94ead86e157eb68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#abeea766a87048e9a97fb8ac2f2c34110">startForeground</a> (int32_t id, <a class="el" href="../../df/da4/classgaia_1_1service_1_1_notification.html">gaia::service::Notification</a> *notification)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this delegate run in the foreground, supplying the ongoing notification to be shown to the user while in this state.  <a href="#abeea766a87048e9a97fb8ac2f2c34110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#ab21bf1aec907f9f961ad5d5146601d77">stopForeground</a> (bool removeNotification)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this delegate from foreground state, allowing it to be killed if more memory is needed.  <a href="#ab21bf1aec907f9f961ad5d5146601d77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/df5/classgaia_1_1core_1_1_display.html">Display</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a75a4943b43624f802f084700a53ea8ce">getDisplayN</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="../../d2/df5/classgaia_1_1core_1_1_display.html" title="Provides information about the size and density of a logical display.">Display</a> instance for the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>.  <a href="#a75a4943b43624f802f084700a53ea8ce"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a> is for creating an extenal thread, in a process differs from a <a class="el" href="../../db/d3f/classgaia_1_1core_1_1_page.html" title="An page is a single, focused thing that the user can do.">Page</a> process, to process the long-term task. </p>
<p>There are two methods almost all subclasses of <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a> will implement:</p>
<ul>
<li>
<p class="startli"><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca" title="This hook is where you implement your asynchronously tasks.">onInvoke</a> is where you want your delegate to excercise the authority. Here you will not be asked to return as soon as possible , but to do any task until time is up.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470" title="This hook is where you stop or pause your asynchronously tasks.">onTimedout</a> is where you deal with the time-out. Most importantly, any changes made by the user should at this point be committed (usually to the {android.content.ContentProvider} holding the data). </li>
</ul>
<p>The COS system will allow the delegate doing its work at proper time. Any task, within the time slice, will not be asked to give up its ownership of thread. Once the time is up, the hook <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470" title="This hook is where you stop or pause your asynchronously tasks.">onTimedout</a> will be called to notice.</p>
<p>The COS system will attempt to keep the process hosting a delegate around as long as the delegate invoked or has principal alive. When running low on memory and needing to kill existing processes, the priority of a process hosting the delegate will be the higher of the following possibilities:</p>
<ul>
<li>
<p class="startli"></p>
<p class="endli">If the delegate is currently executing code in its <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a2bb4e0166d3f42eb5e3a1c19eebe6f5a">onLoad()</a>, <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca">onInvoke()</a>, or <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470">onTimedout()</a> methods, then the hosting process will be a foreground process to ensure this code can execute without being killed. </p>
</li>
<li>
<p class="startli"></p>
<p class="endli">If the delegate has been started, then its hosting process is considered to be less important than any processes that are currently visible to the user on-screen, but more important than any process not visible. Because only a few processes are generally visible to the user, this means that the delegate should not be killed except in extreme low memory conditions. </p>
</li>
<li>
<p class="startli"></p>
<p class="endli">The delegate's hosting process is never less important than the page which dispatches the delegate at meanwhile. That is, if its principal is visible to the user, then the delegate itself is considered to be visible. </p>
</li>
<li>
<p class="startli"></p>
<p class="endli">An invoked delegate can use the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a65bd46f422f886726101e4a744189464" title="Renew the time slice.">renewPeriod</a> or <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a24b686f200d32acb7ed3b5af1c1de41e" title="Reign the time slice.">reignPeriod</a> API to put the delegate in a foreground state, where the system considers it to be something the user is actively aware of and thus not a candidate for killing when low on memory. (It is still theoretically possible for the delegate to be dismissed under extreme memory or performance pressure from the current foreground application, but in practice this should not be a concern.) </p>
</li>
</ul>
<p>Note this means that most of the time your delegate is running, it may be killed by the system if it is under heavy memory or performance pressure. If this happens, the system will later try to redispatch the delegate. An important consequence of this is that if you implement <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca">onInvoke()</a> to schedule work to be done asynchronously or in another thread, then you may want to implement <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470">onTimedout()</a> to finish the asynchronous tasks, so that it does not get lost if your delegate is killed while processing it.</p>
<p>Consider that there will not be any other application components running in the same process as the delegate. It means, of course, there will not be any UI thread or response-sensitive issues of the process itself. </p>

<p>Definition at line <a class="el" href="../../d9/dfd/_delegate_8h_source.html#l00098">98</a> of file <a class="el" href="../../d9/dfd/_delegate_8h_source.html">Delegate.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adec18e573d22afa271f8f87c2d48a6b1"></a><!-- doxytag: member="gaia::core::Delegate::Delegate" ref="adec18e573d22afa271f8f87c2d48a6b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gaia::core::Delegate::Delegate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To create the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>. </p>
<p>Some initialization code will be embedded here. </p>

</div>
</div>
<a class="anchor" id="a267429aa412fc3a85e2fd27117281c12"></a><!-- doxytag: member="gaia::core::Delegate::~Delegate" ref="a267429aa412fc3a85e2fd27117281c12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual gaia::core::Delegate::~Delegate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To destroy the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>. </p>
<p>Some aftermath-dealing code will be embedded here. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a75a4943b43624f802f084700a53ea8ce"></a><!-- doxytag: member="gaia::core::Delegate::getDisplayN" ref="a75a4943b43624f802f084700a53ea8ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/df5/classgaia_1_1core_1_1_display.html">Display</a>* gaia::core::Delegate::getDisplayN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="../../d2/df5/classgaia_1_1core_1_1_display.html" title="Provides information about the size and density of a logical display.">Display</a> instance for the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="../../d2/df5/classgaia_1_1core_1_1_display.html" title="Provides information about the size and density of a logical display.">Display</a> instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a05f30a84eff2b60e1ed844265fe90632"></a><!-- doxytag: member="gaia::core::Delegate::onBind" ref="a05f30a84eff2b60e1ed844265fe90632" args="(Demand *demand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html">IBinder</a>* gaia::core::Delegate::onBind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *&#160;</td>
          <td class="paramname"><em>demand</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the communication channel to the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>. </p>
<p>May return null if clients can not bind to the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>. The returned <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html">IBinder</a> is usually for a complex interface that has been cidl described using cidl.</p>
<p><em>Note that unlike other application components, calls on to the <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html" title="Base class and low-level protocol for a remotable object.">IBinder</a> interface returned here may not happen on the main thread of the process</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">demand</td><td>The <a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html" title="An Demand is an abstract description of an operation to be performed.">Demand</a> that was used to bind to this <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>, as given to <a class="el" href="../../d0/d05/classgaia_1_1core_1_1_context.html#a98e10622c919f1728f24cb99024db3da" title="Connect to an application delegate, creating it if needed.">Context::bindDelegate</a>. Note that any extras that were included with the <a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html" title="An Demand is an abstract description of an operation to be performed.">Demand</a> at that point will <em>not</em> be seen here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return an <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html" title="Base class and low-level protocol for a remotable object.">IBinder</a> through which clients can call on to the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af3d8268be2891b030e1acc80c1eb904e"></a><!-- doxytag: member="gaia::core::Delegate::onConfigurationChanged" ref="af3d8268be2891b030e1acc80c1eb904e" args="(gaia::content::Configuration *newConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::onConfigurationChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/df1/classgaia_1_1content_1_1_configuration.html">gaia::content::Configuration</a> *&#160;</td>
          <td class="paramname"><em>newConfig</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the system when the device configuration changes while your page is running. </p>
<p>Note that this will <em>only</em> be called if you have selected configurations you would like to handle with the gaia::R::attr::configChanges attribute in your manifest. If any configuration change occurs that is not selected to be reported by that attribute, then instead of reporting it the system will stop and restart the page (to have it launched with the new configuration).</p>
<p>At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newConfig</td><td>The new device configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e82e97e59b73247fcd28bde3ecef2e4"></a><!-- doxytag: member="gaia::core::Delegate::onDismiss" ref="a7e82e97e59b73247fcd28bde3ecef2e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::onDismiss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This hook represents that the delegate is going to be removed from process. </p>
<p>Try to deal with the aftermath of the whole session. Don't take too long in this hook, or ANR will be triggered. </p>

<p>Reimplemented in <a class="el" href="../../d4/d35/classgaia_1_1service_1_1_i_m_e_service.html#a23242e1ef95f6ea0f699822ec3c620b2">gaia::service::IMEService</a>.</p>

</div>
</div>
<a class="anchor" id="a4d1eb2a7b0751d35d9fdc29bca7d06ca"></a><!-- doxytag: member="gaia::core::Delegate::onInvoke" ref="a4d1eb2a7b0751d35d9fdc29bca7d06ca" args="(Demand *demand, int32_t flags, int32_t invokeId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::onInvoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *&#160;</td>
          <td class="paramname"><em>demand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>invokeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This hook is where you implement your asynchronously tasks. </p>
<p>Notice that you will not be asked to return until the <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470" title="This hook is where you stop or pause your asynchronously tasks.">onTimedout</a> is called. Please be reminded that once the hook <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8e6d2c5d3a43a9ac50916c65545ff470" title="This hook is where you stop or pause your asynchronously tasks.">onTimedout</a> is called, you should give up the ownership of the thread, or the ANR will be triggered. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a102f4eb11d46da93c94ead86e157eb68" title="Stop the delegate if the most recent time it was invoked was invokeId.">revokeSelf(int32_t)</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2bb4e0166d3f42eb5e3a1c19eebe6f5a"></a><!-- doxytag: member="gaia::core::Delegate::onLoad" ref="a2bb4e0166d3f42eb5e3a1c19eebe6f5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::onLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This hook represents that the delegate has been loaded into process. </p>
<p>Try to prepare resource for upcoming session. Don't take too long in this hook, or ANR will be triggered. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca" title="This hook is where you implement your asynchronously tasks.">onInvoke</a></dd></dl>

<p>Reimplemented in <a class="el" href="../../d4/d35/classgaia_1_1service_1_1_i_m_e_service.html#a6945b8eafbdcaeafc3b1442619415e72">gaia::service::IMEService</a>.</p>

</div>
</div>
<a class="anchor" id="a33ee05fc5c1f4b5068f3ab6904a0268e"></a><!-- doxytag: member="gaia::core::Delegate::onRebind" ref="a33ee05fc5c1f4b5068f3ab6904a0268e" args="(Demand *demand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gaia::core::Delegate::onRebind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *&#160;</td>
          <td class="paramname"><em>demand</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when new clients have connected to the service, after it had previously been notified that all had disconnected in its <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a821f8c40c0a2299caf720671cab725a0">onUnbind</a>. </p>
<p>This will only be called if the implementation of <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a821f8c40c0a2299caf720671cab725a0">onUnbind</a> was overridden to return true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">intent</td><td>The <a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html" title="An Demand is an abstract description of an operation to be performed.">Demand</a> that was used to bind to this service, as given to <a class="el" href="../../d0/d05/classgaia_1_1core_1_1_context.html#a98e10622c919f1728f24cb99024db3da">Context::bindDelegate</a>. Note that any extras that were included with the <a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html" title="An Demand is an abstract description of an operation to be performed.">Demand</a> at that point will <em>not</em> be seen here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e6d2c5d3a43a9ac50916c65545ff470"></a><!-- doxytag: member="gaia::core::Delegate::onTimedout" ref="a8e6d2c5d3a43a9ac50916c65545ff470" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::onTimedout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This hook is where you stop or pause your asynchronously tasks. </p>
<p>If you are attempting to pause, save the <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html" title="A mapping from String values to various primitive types.">core::Persistence</a> here just in case the delegate is, some how, killed due to the system resource requiring pressure. Don't take too long in this hook, or ANR will be triggered. </p>

</div>
</div>
<a class="anchor" id="a5c0e94bab09102d3f154931a76ea690d"></a><!-- doxytag: member="gaia::core::Delegate::onTrimMemory" ref="a5c0e94bab09102d3f154931a76ea690d" args="(int32_t level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::onTrimMemory </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Trim memory level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a821f8c40c0a2299caf720671cab725a0"></a><!-- doxytag: member="gaia::core::Delegate::onUnbind" ref="a821f8c40c0a2299caf720671cab725a0" args="(Demand *demand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gaia::core::Delegate::onUnbind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html">Demand</a> *&#160;</td>
          <td class="paramname"><em>demand</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when all clients have disconnected from a particular interface published by the delegate. </p>
<p>The default implementation does nothing and returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">demand</td><td>The <a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html" title="An Demand is an abstract description of an operation to be performed.">Demand</a> that was used to bind to this delegate, as given to <a class="el" href="../../d0/d05/classgaia_1_1core_1_1_context.html#a98e10622c919f1728f24cb99024db3da">Context::bindDelegate</a>. Note that any extras that were included with the <a class="el" href="../../d4/d95/classgaia_1_1core_1_1_demand.html" title="An Demand is an abstract description of an operation to be performed.">Demand</a> at that point will <em>not</em> be seen here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return true if you would like to have the delegate's <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a33ee05fc5c1f4b5068f3ab6904a0268e">onRebind</a> method later called when new clients bind to it. </dd></dl>

</div>
</div>
<a class="anchor" id="a24b686f200d32acb7ed3b5af1c1de41e"></a><!-- doxytag: member="gaia::core::Delegate::reignPeriod" ref="a24b686f200d32acb7ed3b5af1c1de41e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::reignPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reign the time slice. </p>
<p>Give a much longer new time slice for delegate to invoke, of course, if the memory or performance pressure of the system is proper. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result </dd></dl>

</div>
</div>
<a class="anchor" id="a65bd46f422f886726101e4a744189464"></a><!-- doxytag: member="gaia::core::Delegate::renewPeriod" ref="a65bd46f422f886726101e4a744189464" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html#a466c4872b413e4c3c7668155dfd9d0d8">Result</a> gaia::core::Delegate::renewPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renew the time slice. </p>
<p>Give a new time slice to delegate for invocation, of course, if the memory or performance pressure of the system is at proper situation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result </dd></dl>

</div>
</div>
<a class="anchor" id="a8be459dd8c9ced1348dcf5c406a828c9"></a><!-- doxytag: member="gaia::core::Delegate::revokeSelf" ref="a8be459dd8c9ced1348dcf5c406a828c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::Delegate::revokeSelf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop the delegate, if it was previously invoked. </p>

</div>
</div>
<a class="anchor" id="a102f4eb11d46da93c94ead86e157eb68"></a><!-- doxytag: member="gaia::core::Delegate::revokeSelf" ref="a102f4eb11d46da93c94ead86e157eb68" args="(int32_t invokeId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gaia::core::Delegate::revokeSelf </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>invokeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop the delegate if the most recent time it was invoked was <em>invokeId</em>. </p>
<p>This allows you to safely avoid stopping if there is a start request from a client that you haven't yet seen in <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca" title="This hook is where you implement your asynchronously tasks.">onInvoke</a>.</p>
<p><em>Be careful about ordering of your calls to this function.</em>. If you call this function with the most-recently received ID before you have called it for previously received IDs, the delegate will be immediately stopped anyway. If you may end up processing IDs out of order (such as by dispatching them on separate threads), then you are responsible for stopping them in the same order you received them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">invokeId</td><td>The most recent start identifier received in <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a4d1eb2a7b0751d35d9fdc29bca7d06ca" title="This hook is where you implement your asynchronously tasks.">onInvoke</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the invokeId matches the last start request and the delegate will be stopped, else false.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#a8be459dd8c9ced1348dcf5c406a828c9" title="Stop the delegate, if it was previously invoked.">revokeSelf()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abeea766a87048e9a97fb8ac2f2c34110"></a><!-- doxytag: member="gaia::core::Delegate::startForeground" ref="abeea766a87048e9a97fb8ac2f2c34110" args="(int32_t id, gaia::service::Notification *notification)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::Delegate::startForeground </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/da4/classgaia_1_1service_1_1_notification.html">gaia::service::Notification</a> *&#160;</td>
          <td class="paramname"><em>notification</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make this delegate run in the foreground, supplying the ongoing notification to be shown to the user while in this state. </p>
<p>By default delegate are background, meaning that if the system needs to kill them to reclaim more memory (such as to display a large page in a web browser), they can be killed without too much harm. You can set this flag if killing your delegate would be disruptive to the user, such as if your delegate is performing background music playback, so the user would notice if their music stopped playing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier for this notification as per <a class="el" href="../../">NotificationManager::notify(int32_t, service::Notification*)</a>. </td></tr>
    <tr><td class="paramname">notification</td><td>The Notification to be displayed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#ab21bf1aec907f9f961ad5d5146601d77" title="Remove this delegate from foreground state, allowing it to be killed if more memory is needed...">stopForeground(bool)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab21bf1aec907f9f961ad5d5146601d77"></a><!-- doxytag: member="gaia::core::Delegate::stopForeground" ref="ab21bf1aec907f9f961ad5d5146601d77" args="(bool removeNotification)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gaia::core::Delegate::stopForeground </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeNotification</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove this delegate from foreground state, allowing it to be killed if more memory is needed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">removeNotification</td><td>If true, the notification previously provided to <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#abeea766a87048e9a97fb8ac2f2c34110">startForeground</a> will be removed. Otherwise it will remain until a later call removes it (or the delegate is dismissed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html#abeea766a87048e9a97fb8ac2f2c34110" title="Make this delegate run in the foreground, supplying the ongoing notification to be shown to the user ...">startForeground(int32_t, service::Notification*)</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/gpdbuildserver3/Jenkins_Workspace/workspace/BuildGaia2SDKLauncher/sdk/include/gaia/core/<a class="el" href="../../d9/dfd/_delegate_8h_source.html">Delegate.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 12 2013 04:17:40 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
