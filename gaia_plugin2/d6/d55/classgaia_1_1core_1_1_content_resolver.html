<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>gaia::core::ContentResolver Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="../../dynsections.js"></script>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d9/db5/namespacegaia.html">gaia</a>      </li>
      <li class="navelem"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">gaia::core::ContentResolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="gaia::core::ContentResolver" -->
<p>This class provides applications access to specific content provider.  
 <a href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a>&gt;</code></p>

<p><a href="../../d5/ded/classgaia_1_1core_1_1_content_resolver-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a70882b6567ac6e654f32a05a40798554">ContentResolver</a> (ContentResolverProxy *contentResolver)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html" title="This class provides applications access to specific content provider.">ContentResolver</a> constructor.  <a href="#a70882b6567ac6e654f32a05a40798554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a3f9031d0ca62fe0e8e8092781fce63f3">~ContentResolver</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html" title="This class provides applications access to specific content provider.">ContentResolver</a> destructor.  <a href="#a3f9031d0ca62fe0e8e8092781fce63f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d72/classgaia_1_1content_1_1_content_provider_client.html">content::ContentProviderClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a50dd734655471f51ad650ffc429882c5">acquireContentProviderClientN</a> (const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ContentProviderClient that is associated with the ContentProvider with the authority of name, starting the provider if necessary.  <a href="#a50dd734655471f51ad650ffc429882c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d72/classgaia_1_1content_1_1_content_provider_client.html">content::ContentProviderClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aef98d7e8471f30caa3ebb22372052c64">acquireUnstableContentProviderClientN</a> (const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like acquireContentProviderClient(String), but for use when you do not trust the stability of the target content provider.  <a href="#aef98d7e8471f30caa3ebb22372052c64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a9b3f3f161799ea7a8280f7f092b8ecc2">registerContentObserver</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, bool notifyForDescendents, const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> &amp;observer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an observer class that gets callbacks when data identified by a given content URI changes.  <a href="#a9b3f3f161799ea7a8280f7f092b8ecc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a425b781bdaefa347cfffb71586bf97cc">unregisterContentObserver</a> (const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> &amp;observer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a change observer.  <a href="#a425b781bdaefa347cfffb71586bf97cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a84e1dd8f11f7b45cce0a7e71177c01fb">notifyChange</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> *observer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify registered observers that a row was updated.  <a href="#a84e1dd8f11f7b45cce0a7e71177c01fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a5146c797c7de71dae87e8045665022e8">notifyChange</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> *observer, bool syncToNetwork)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify registered observers that a row was updated.  <a href="#a5146c797c7de71dae87e8045665022e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d26/classgaia_1_1storage_1_1_input_stream.html">storage::InputStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aca3c27f5fed3f097771edb7bef36e09b">openInputStreamN</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a stream on to the content associated with a content URI.  <a href="#aca3c27f5fed3f097771edb7bef36e09b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d9f/classgaia_1_1storage_1_1_parcel_file_descriptor.html">storage::ParcelFileDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a8acd1458b4ee73bbd8a4b7d2841bffe3">openFileDescriptorN</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a raw file descriptor to access data under a "content:" URI.  <a href="#a8acd1458b4ee73bbd8a4b7d2841bffe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/de8/classgaia_1_1storage_1_1_cursor.html">storage::Cursor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ac373b0c95844ac119a69c776556df91e">queryN</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const projection, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const selection, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const selectionArgs, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const sortOrder)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aebaae02adb6d2b924e9608aec06bf52b">getType</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MIME type of the given content URL.  <a href="#aebaae02adb6d2b924e9608aec06bf52b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a7c25b3adab5c8bb6b5d59ae59ddc112b">insert</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &amp;values)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a row into a table at the given URL.  <a href="#a7c25b3adab5c8bb6b5d59ae59ddc112b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a22032bf73cd14852b24a382c15ea6e45">bulkInsert</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">base::Array</a>&lt; <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &gt; &amp;values)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts multiple rows into a table at the given URL.  <a href="#a22032bf73cd14852b24a382c15ea6e45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d7d/classgaia_1_1content_1_1_content_provider_result_array.html">content::ContentProviderResultArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad8702e3944e23c67cae8e8d821ec10ee">applyBatch</a> (const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority, const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">base::Array</a>&lt; content::ContentProviderOperation * &gt; &amp;operations)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies each of the <a class="el" href="../../">ContentProviderOperation</a> objects and returns an array of their results.  <a href="#ad8702e3944e23c67cae8e8d821ec10ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a92c3a343b24f85fd812d4755ba7d23c3">deleteData</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const selection, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const selectionArgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes row(s) specified by a content URI.  <a href="#a92c3a343b24f85fd812d4755ba7d23c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad334564ee2db86c6501b6edd48e2a72f">update</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &amp;values, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const selection, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const selectionArgs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update row(s) in a content URI.  <a href="#ad334564ee2db86c6501b6edd48e2a72f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a8f37b4174b106832c9e00ab746c4ffcc">call</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;method, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;arg, const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> *extras)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a provider-defined method.  <a href="#a8f37b4174b106832c9e00ab746c4ffcc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a187efa7e03e216b2ebeea94ecbf73197">SYNC_EXTRAS_EXPEDITED</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If this extra is set to true then the sync will be priority.  <a href="#a187efa7e03e216b2ebeea94ecbf73197"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af826522f9a219a0b937144411f8253ec">SYNC_EXTRAS_IGNORE_SETTINGS</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If this extra is set to true then the sync settings (like <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a921ef4b41422fcd9c244fe77745800c4" title="Check if the provider should be synced when a network tickle is received.">getSyncAutomatically()</a>) are ignored by the sync scheduler.  <a href="#af826522f9a219a0b937144411f8253ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a5852d2927a461d2e4bd79a43f21023a2">SYNC_EXTRAS_IGNORE_BACKOFF</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If this extra is set to true then any backoffs for the initial attempt (e.g.  <a href="#a5852d2927a461d2e4bd79a43f21023a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aa63ac2074512211cbe559b465ca6b45f">SYNC_EXTRAS_DO_NOT_RETRY</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If this extra is set to true then the request will not be retried if it fails.  <a href="#aa63ac2074512211cbe559b465ca6b45f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af2ef59495a6c4966686ec667a76095dc">SYNC_EXTRAS_MANUAL</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting this extra is the equivalent of setting both <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af826522f9a219a0b937144411f8253ec">SYNC_EXTRAS_IGNORE_SETTINGS</a> and <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a5852d2927a461d2e4bd79a43f21023a2">SYNC_EXTRAS_IGNORE_BACKOFF</a>.  <a href="#af2ef59495a6c4966686ec667a76095dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af6d1e5f0d99a20b19ecc927ad8cbadfa">SYNC_EXTRAS_UPLOAD</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a82f7b7b07781bf346e421bc6beff694d">SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aecbed902e02593edd7e897178eea2b6c">SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#adcb448bdda5aa9f2dd843eb7009e21f6">SYNC_EXTRAS_INITIALIZE</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a158b1a75ca1f1a96c9e1c01113662558">requestSync</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority, const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> *extras)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous sync operation.  <a href="#a158b1a75ca1f1a96c9e1c01113662558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad778c642dd7e5f43110f0e6a7ace8011">cancelSync</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any active or pending syncs that match account and authority.  <a href="#ad778c642dd7e5f43110f0e6a7ace8011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <br class="typebreak"/>
<a class="el" href="../../dc/db7/classgaia_1_1content_1_1_sync_adapter_type_array.html">content::SyncAdapterTypeArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a387f0ce1c4c5e5e6b5dbf2ae5aadbfc1">getSyncAdapterTypes</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the SyncAdapters that are known to the system.  <a href="#a387f0ce1c4c5e5e6b5dbf2ae5aadbfc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a921ef4b41422fcd9c244fe77745800c4">getSyncAutomatically</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provider should be synced when a network tickle is received.  <a href="#a921ef4b41422fcd9c244fe77745800c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ac14226ca4706d1ec89b4dde3ea14b298">setSyncAutomatically</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority, bool sync)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not the provider is synced when it receives a network tickle.  <a href="#ac14226ca4706d1ec89b4dde3ea14b298"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a3ad50a88ee46c0ef8c4081f4c76fd6de">addPeriodicSync</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> &amp;account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority, const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> &amp;extras, int64_t pollFrequency)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a sync should be requested with the specified the account, authority, and extras at the given frequency.  <a href="#a3ad50a88ee46c0ef8c4081f4c76fd6de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a3a577715774e12b86018bc8d385eebad">removePeriodicSync</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> &amp;account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority, const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> &amp;extras)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a periodic sync.  <a href="#a3a577715774e12b86018bc8d385eebad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d86/classgaia_1_1content_1_1_periodic_sync_array.html">content::PeriodicSyncArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a1f446510f7595fdc95bacb2c3b71ebc5">getPeriodicSyncs</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> &amp;account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of information about the periodic syncs for the given account and authority.  <a href="#a1f446510f7595fdc95bacb2c3b71ebc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a82c6fb206d272749059277ac1225bb40">getIsSyncable</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this account/provider is syncable.  <a href="#a82c6fb206d272749059277ac1225bb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a2c74433479367e7339f81a53044de59e">setIsSyncable</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority, int32_t syncable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this account/provider is syncable.  <a href="#a2c74433479367e7339f81a53044de59e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af89078b0caa375f4faa9d82c6f517edd">getMasterSyncAutomatically</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the master auto-sync setting that applies to all the providers and accounts.  <a href="#af89078b0caa375f4faa9d82c6f517edd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a544f510cc4475bdacea195f06867ffe8">setMasterSyncAutomatically</a> (bool sync)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the master auto-sync setting that applies to all the providers and accounts.  <a href="#a544f510cc4475bdacea195f06867ffe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a9ed7876de33bf5437da4c3774569a6d3">isSyncActive</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is currently a sync operation for the given account or authority in the pending list, or actively being processed.  <a href="#a9ed7876de33bf5437da4c3774569a6d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#adfab9660b30342f2ba90812b0b7b810b">isSyncPending</a> (const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *account, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;authority)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the pending status is true of any matching authorities.  <a href="#adfab9660b30342f2ba90812b0b7b810b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../de/d5e/classgaia_1_1content_1_1_sync_info_array.html">content::SyncInfoArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a226cfd9372f01ad082a57541ea63c2c4">getCurrentSyncs</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with information about all the active syncs.  <a href="#a226cfd9372f01ad082a57541ea63c2c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af0a5b3d993a1a801506dd2320a8e4fa8">addStatusChangeListener</a> (int32_t mask, const <a class="el" href="../../d0/d78/classgaia_1_1content_1_1_sync_status_observer.html">content::SyncStatusObserver</a> &amp;callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request notifications when the different aspects of the SyncManager change.  <a href="#af0a5b3d993a1a801506dd2320a8e4fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a8c04cbca407352bae43ce912fdfc7ceb">removeStatusChangeListener</a> (const <a class="el" href="../../d0/d78/classgaia_1_1content_1_1_sync_status_observer.html">content::SyncStatusObserver</a> &amp;callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously registered status change listener.  <a href="#a8c04cbca407352bae43ce912fdfc7ceb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a89e810efefc5c7b73ef3a7f0ec789946">SYNC_OBSERVER_TYPE_SETTINGS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aacf8480c42ef9d227e85ad132f24d760">SYNC_OBSERVER_TYPE_PENDING</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a06706559d947eecc803956ea5284f018">SYNC_OBSERVER_TYPE_ACTIVE</a></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ab091f555e21189907c8067ad9c920211">ContentResolver</a> (const <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a> &amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a9b9b6c20231a55445e06af83ef578d20">operator=</a> (const <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a> &amp;o)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ContentResolverProxy *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad64f2dd7c2d1ca5570e25db2a684f2d2">mpContentResolverProxy</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class provides applications access to specific content provider. </p>

<p>Definition at line <a class="el" href="../../d2/d58/_content_resolver_8h_source.html#l00050">50</a> of file <a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a70882b6567ac6e654f32a05a40798554"></a><!-- doxytag: member="gaia::core::ContentResolver::ContentResolver" ref="a70882b6567ac6e654f32a05a40798554" args="(ContentResolverProxy *contentResolver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a70882b6567ac6e654f32a05a40798554">gaia::core::ContentResolver::ContentResolver</a> </td>
          <td>(</td>
          <td class="paramtype">ContentResolverProxy *&#160;</td>
          <td class="paramname"><em>contentResolver</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html" title="This class provides applications access to specific content provider.">ContentResolver</a> constructor. </p>

</div>
</div>
<a class="anchor" id="a3f9031d0ca62fe0e8e8092781fce63f3"></a><!-- doxytag: member="gaia::core::ContentResolver::~ContentResolver" ref="a3f9031d0ca62fe0e8e8092781fce63f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a3f9031d0ca62fe0e8e8092781fce63f3">gaia::core::ContentResolver::~ContentResolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html" title="This class provides applications access to specific content provider.">ContentResolver</a> destructor. </p>

</div>
</div>
<a class="anchor" id="ab091f555e21189907c8067ad9c920211"></a><!-- doxytag: member="gaia::core::ContentResolver::ContentResolver" ref="ab091f555e21189907c8067ad9c920211" args="(const ContentResolver &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a70882b6567ac6e654f32a05a40798554">gaia::core::ContentResolver::ContentResolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [explicit, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a50dd734655471f51ad650ffc429882c5"></a><!-- doxytag: member="gaia::core::ContentResolver::acquireContentProviderClientN" ref="a50dd734655471f51ad650ffc429882c5" args="(const base::String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d72/classgaia_1_1content_1_1_content_provider_client.html">content::ContentProviderClient</a>* <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a50dd734655471f51ad650ffc429882c5">gaia::core::ContentResolver::acquireContentProviderClientN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a ContentProviderClient that is associated with the ContentProvider with the authority of name, starting the provider if necessary. </p>
<p>Returns NULL if there is no provider associated wih the name. The caller must indicate that they are done with the provider by calling release() which will allow the system to release the provider it it determines that there is no other reason for keeping it active.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>specifies which provider should be acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a ContentProviderClient that is associated with the ContentProvider with the authority of name or NULL if there isn't one. </dd></dl>

</div>
</div>
<a class="anchor" id="aef98d7e8471f30caa3ebb22372052c64"></a><!-- doxytag: member="gaia::core::ContentResolver::acquireUnstableContentProviderClientN" ref="aef98d7e8471f30caa3ebb22372052c64" args="(const base::String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d72/classgaia_1_1content_1_1_content_provider_client.html">content::ContentProviderClient</a>* <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aef98d7e8471f30caa3ebb22372052c64">gaia::core::ContentResolver::acquireUnstableContentProviderClientN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like acquireContentProviderClient(String), but for use when you do not trust the stability of the target content provider. </p>
<p>This turns off the mechanism in the platform clean up processes that are dependent on a content provider if that content provider's process goes away. Normally you can safely assume that once you have acquired a provider, you can freely use it as needed and it won't disappear, even if your process is in the background. If using this method, you need to take care to deal with any failures when communicating with the provider, and be sure to close it so that it can be re-opened later. </p>

</div>
</div>
<a class="anchor" id="a3ad50a88ee46c0ef8c4081f4c76fd6de"></a><!-- doxytag: member="gaia::core::ContentResolver::addPeriodicSync" ref="a3ad50a88ee46c0ef8c4081f4c76fd6de" args="(const accounts::Account &amp;account, const base::String &amp;authority, const Persistence &amp;extras, int64_t pollFrequency)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a3ad50a88ee46c0ef8c4081f4c76fd6de">gaia::core::ContentResolver::addPeriodicSync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> &amp;&#160;</td>
          <td class="paramname"><em>extras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pollFrequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies that a sync should be requested with the specified the account, authority, and extras at the given frequency. </p>
<p>If there is already another periodic sync scheduled with the account, authority and extras then a new periodic sync won't be added, instead the frequency of the previous one will be updated. </p>
<p>These periodic syncs honor the "syncAutomatically" and "masterSyncAutomatically" settings. Although these sync are scheduled at the specified frequency, it may take longer for it to actually be started if other syncs are ahead of it in the sync operation queue. This means that the actual start time may drift. </p>
<p>Periodic syncs are not allowed to have any of <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aa63ac2074512211cbe559b465ca6b45f">SYNC_EXTRAS_DO_NOT_RETRY</a>, <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a5852d2927a461d2e4bd79a43f21023a2">SYNC_EXTRAS_IGNORE_BACKOFF</a>, <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af826522f9a219a0b937144411f8253ec">SYNC_EXTRAS_IGNORE_SETTINGS</a>, <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#adcb448bdda5aa9f2dd843eb7009e21f6">SYNC_EXTRAS_INITIALIZE</a>, <a class="el" href="../../">SYNC_EXTRAS_FORCE</a>, <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a187efa7e03e216b2ebeea94ecbf73197">SYNC_EXTRAS_EXPEDITED</a>, <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af2ef59495a6c4966686ec667a76095dc">SYNC_EXTRAS_MANUAL</a> set to true. If any are supplied then an <a class="el" href="../../">IllegalArgumentException</a> will be thrown.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account to specify in the sync </td></tr>
    <tr><td class="paramname">authority</td><td>the provider to specify in the sync request </td></tr>
    <tr><td class="paramname">extras</td><td>extra parameters to go along with the sync request </td></tr>
    <tr><td class="paramname">pollFrequency</td><td>how frequently the sync should be performed, in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0a5b3d993a1a801506dd2320a8e4fa8"></a><!-- doxytag: member="gaia::core::ContentResolver::addStatusChangeListener" ref="af0a5b3d993a1a801506dd2320a8e4fa8" args="(int32_t mask, const content::SyncStatusObserver &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af0a5b3d993a1a801506dd2320a8e4fa8">gaia::core::ContentResolver::addStatusChangeListener</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d78/classgaia_1_1content_1_1_sync_status_observer.html">content::SyncStatusObserver</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request notifications when the different aspects of the SyncManager change. </p>
<p>The different items that can be requested are: </p>
<ul>
<li>
<a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aacf8480c42ef9d227e85ad132f24d760">SYNC_OBSERVER_TYPE_PENDING</a> </li>
<li>
<a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a06706559d947eecc803956ea5284f018">SYNC_OBSERVER_TYPE_ACTIVE</a> </li>
<li>
<a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a89e810efefc5c7b73ef3a7f0ec789946">SYNC_OBSERVER_TYPE_SETTINGS</a> </li>
</ul>
<p>The caller can set one or more of the status types in the mask for any given listener registration. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the status change types that will cause the callback to be invoked </td></tr>
    <tr><td class="paramname">callback</td><td>observer to be invoked when the status changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8702e3944e23c67cae8e8d821ec10ee"></a><!-- doxytag: member="gaia::core::ContentResolver::applyBatch" ref="ad8702e3944e23c67cae8e8d821ec10ee" args="(const base::String &amp;authority, const base::Array&lt; content::ContentProviderOperation * &gt; &amp;operations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d7d/classgaia_1_1content_1_1_content_provider_result_array.html">content::ContentProviderResultArray</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad8702e3944e23c67cae8e8d821ec10ee">gaia::core::ContentResolver::applyBatch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">base::Array</a>&lt; content::ContentProviderOperation * &gt; &amp;&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies each of the <a class="el" href="../../">ContentProviderOperation</a> objects and returns an array of their results. </p>
<p>Passes through OperationApplicationException, which may be thrown by the call to <a class="el" href="../../">ContentProviderOperation#apply</a>. If all the applications succeed then a <a class="el" href="../../">ContentProviderResult</a> array with the same number of elements as the operations will be returned. It is implementation-specific how many, if any, operations will have been successfully applied if a call to apply results in a <a class="el" href="../../">OperationApplicationException</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">authority</td><td>the authority of the ContentProvider to which this batch should be applied </td></tr>
    <tr><td class="paramname">operations</td><td>the operations to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the results of the applications</dd></dl>
<p>See <a class="el" href="../../">ContentProviderOperation#apply</a> for more information. </p>

</div>
</div>
<a class="anchor" id="a22032bf73cd14852b24a382c15ea6e45"></a><!-- doxytag: member="gaia::core::ContentResolver::bulkInsert" ref="a22032bf73cd14852b24a382c15ea6e45" args="(const net::Uri &amp;uri, const base::Array&lt; content::ContentValues &gt; &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a22032bf73cd14852b24a382c15ea6e45">gaia::core::ContentResolver::bulkInsert</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">base::Array</a>&lt; <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts multiple rows into a table at the given URL. </p>
<p>This function make no guarantees about the atomicity of the insertions.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL of the table to insert into.  The initial values for the newly inserted rows. The key is the column name for the field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of newly created rows. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f37b4174b106832c9e00ab746c4ffcc"></a><!-- doxytag: member="gaia::core::ContentResolver::call" ref="a8f37b4174b106832c9e00ab746c4ffcc" args="(const net::Uri &amp;uri, const base::String &amp;method, const base::String &amp;arg, const Persistence *extras)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a8f37b4174b106832c9e00ab746c4ffcc">gaia::core::ContentResolver::call</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> *&#160;</td>
          <td class="paramname"><em>extras</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call a provider-defined method. </p>
<p>This can be used to implement read or write interfaces which are cheaper than using a Cursor and/or do not fit into the traditional table model.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>provider-defined method name to call. Opaque to framework, but must be non-null. </td></tr>
    <tr><td class="paramname">arg</td><td>provider-defined String argument. May be null. </td></tr>
    <tr><td class="paramname">extras</td><td>provider-defined Bundle argument. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a result Bundle, possibly null. Will be null if the ContentProvider does not implement call. </dd></dl>

</div>
</div>
<a class="anchor" id="ad778c642dd7e5f43110f0e6a7ace8011"></a><!-- doxytag: member="gaia::core::ContentResolver::cancelSync" ref="ad778c642dd7e5f43110f0e6a7ace8011" args="(const accounts::Account *account, const base::String &amp;authority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad778c642dd7e5f43110f0e6a7ace8011">gaia::core::ContentResolver::cancelSync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel any active or pending syncs that match account and authority. </p>
<p>The account and authority can each independently be set to null, which means that syncs with any account or authority, respectively, will match.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>filters the syncs that match by this account </td></tr>
    <tr><td class="paramname">authority</td><td>filters the syncs that match by this authority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92c3a343b24f85fd812d4755ba7d23c3"></a><!-- doxytag: member="gaia::core::ContentResolver::deleteData" ref="a92c3a343b24f85fd812d4755ba7d23c3" args="(const net::Uri &amp;uri, const base::String *const selection, const base::StringArray *const selectionArgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a92c3a343b24f85fd812d4755ba7d23c3">gaia::core::ContentResolver::deleteData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>selectionArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes row(s) specified by a content URI. </p>
<p>If the content provider supports transactions, the deletion will be atomic.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URL of the row to delete. </td></tr>
    <tr><td class="paramname">selection</td><td>A filter to apply to rows before deleting, formatted as an SQL WHERE clause (excluding the WHERE itself). </td></tr>
    <tr><td class="paramname">selectionArgs</td><td>Used to help composite the SQL statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of rows deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a226cfd9372f01ad082a57541ea63c2c4"></a><!-- doxytag: member="gaia::core::ContentResolver::getCurrentSyncs" ref="a226cfd9372f01ad082a57541ea63c2c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../de/d5e/classgaia_1_1content_1_1_sync_info_array.html">content::SyncInfoArray</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a226cfd9372f01ad082a57541ea63c2c4">gaia::core::ContentResolver::getCurrentSyncs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list with information about all the active syncs. </p>
<p>This list will be empty if there are no active syncs. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a List of SyncInfo objects for the currently active syncs. </dd></dl>

</div>
</div>
<a class="anchor" id="a82c6fb206d272749059277ac1225bb40"></a><!-- doxytag: member="gaia::core::ContentResolver::getIsSyncable" ref="a82c6fb206d272749059277ac1225bb40" args="(const accounts::Account *account, const base::String &amp;authority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a82c6fb206d272749059277ac1225bb40">gaia::core::ContentResolver::getIsSyncable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this account/provider is syncable. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;0 if it is syncable, 0 if not, and &lt;0 if the state isn't known yet. </dd></dl>

</div>
</div>
<a class="anchor" id="af89078b0caa375f4faa9d82c6f517edd"></a><!-- doxytag: member="gaia::core::ContentResolver::getMasterSyncAutomatically" ref="af89078b0caa375f4faa9d82c6f517edd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af89078b0caa375f4faa9d82c6f517edd">gaia::core::ContentResolver::getMasterSyncAutomatically</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the master auto-sync setting that applies to all the providers and accounts. </p>
<p>If this is false then the per-provider auto-sync setting is ignored.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the master auto-sync setting that applies to all the providers and accounts </dd></dl>

</div>
</div>
<a class="anchor" id="a1f446510f7595fdc95bacb2c3b71ebc5"></a><!-- doxytag: member="gaia::core::ContentResolver::getPeriodicSyncs" ref="a1f446510f7595fdc95bacb2c3b71ebc5" args="(const accounts::Account &amp;account, const base::String &amp;authority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/d86/classgaia_1_1content_1_1_periodic_sync_array.html">content::PeriodicSyncArray</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a1f446510f7595fdc95bacb2c3b71ebc5">gaia::core::ContentResolver::getPeriodicSyncs</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the list of information about the periodic syncs for the given account and authority. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account whose periodic syncs we are querying </td></tr>
    <tr><td class="paramname">authority</td><td>the provider whose periodic syncs we are querying </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of PeriodicSync objects. This list may be empty but will never be NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a387f0ce1c4c5e5e6b5dbf2ae5aadbfc1"></a><!-- doxytag: member="gaia::core::ContentResolver::getSyncAdapterTypes" ref="a387f0ce1c4c5e5e6b5dbf2ae5aadbfc1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/db7/classgaia_1_1content_1_1_sync_adapter_type_array.html">content::SyncAdapterTypeArray</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a387f0ce1c4c5e5e6b5dbf2ae5aadbfc1">gaia::core::ContentResolver::getSyncAdapterTypes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get information about the SyncAdapters that are known to the system. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an array of SyncAdapters that have registered with the system </dd></dl>

</div>
</div>
<a class="anchor" id="a921ef4b41422fcd9c244fe77745800c4"></a><!-- doxytag: member="gaia::core::ContentResolver::getSyncAutomatically" ref="a921ef4b41422fcd9c244fe77745800c4" args="(const accounts::Account *account, const base::String &amp;authority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a921ef4b41422fcd9c244fe77745800c4">gaia::core::ContentResolver::getSyncAutomatically</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the provider should be synced when a network tickle is received. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account whose setting we are querying </td></tr>
    <tr><td class="paramname">authority</td><td>the provider whose setting we are querying </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the provider should be synced when a network tickle is received </dd></dl>

</div>
</div>
<a class="anchor" id="aebaae02adb6d2b924e9608aec06bf52b"></a><!-- doxytag: member="gaia::core::ContentResolver::getType" ref="aebaae02adb6d2b924e9608aec06bf52b" args="(const net::Uri &amp;uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aebaae02adb6d2b924e9608aec06bf52b">gaia::core::ContentResolver::getType</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the MIME type of the given content URL. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>A Uri identifying content (either a list or specific type), using the content:// scheme. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A MIME type for the content, or null if the URL is invalid or the type is unknown </dd></dl>

</div>
</div>
<a class="anchor" id="a7c25b3adab5c8bb6b5d59ae59ddc112b"></a><!-- doxytag: member="gaia::core::ContentResolver::insert" ref="a7c25b3adab5c8bb6b5d59ae59ddc112b" args="(const net::Uri &amp;uri, const content::ContentValues &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a7c25b3adab5c8bb6b5d59ae59ddc112b">gaia::core::ContentResolver::insert</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts a row into a table at the given URL. </p>
<p>If the content provider supports transactions the insertion will be atomic.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URL of the table to insert into. </td></tr>
    <tr><td class="paramname">values</td><td>The initial values for the newly inserted row. The key is the column name for the field. Passing an empty ContentValues will create an empty row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the URL of the newly created row. NOTE : caller is responsible for deleting returned Uri object </dd></dl>

</div>
</div>
<a class="anchor" id="a9ed7876de33bf5437da4c3774569a6d3"></a><!-- doxytag: member="gaia::core::ContentResolver::isSyncActive" ref="a9ed7876de33bf5437da4c3774569a6d3" args="(const accounts::Account *account, const base::String &amp;authority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a9ed7876de33bf5437da4c3774569a6d3">gaia::core::ContentResolver::isSyncActive</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there is currently a sync operation for the given account or authority in the pending list, or actively being processed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account whose setting we are querying </td></tr>
    <tr><td class="paramname">authority</td><td>the provider whose behavior is being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a sync is active for the given account or authority. </dd></dl>

</div>
</div>
<a class="anchor" id="adfab9660b30342f2ba90812b0b7b810b"></a><!-- doxytag: member="gaia::core::ContentResolver::isSyncPending" ref="adfab9660b30342f2ba90812b0b7b810b" args="(const accounts::Account *account, const base::String &amp;authority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#adfab9660b30342f2ba90812b0b7b810b">gaia::core::ContentResolver::isSyncPending</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the pending status is true of any matching authorities. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account whose setting we are querying </td></tr>
    <tr><td class="paramname">authority</td><td>the provider whose behavior is being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is a pending sync with the matching account and authority </dd></dl>

</div>
</div>
<a class="anchor" id="a84e1dd8f11f7b45cce0a7e71177c01fb"></a><!-- doxytag: member="gaia::core::ContentResolver::notifyChange" ref="a84e1dd8f11f7b45cce0a7e71177c01fb" args="(const net::Uri &amp;uri, const storage::ContentObserver *observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a84e1dd8f11f7b45cce0a7e71177c01fb">gaia::core::ContentResolver::notifyChange</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify registered observers that a row was updated. </p>
<p>To register, call <a class="el" href="../../">boolean, android.database.ContentObserver) registerContentObserver()</a>. By default, CursorAdapter objects will get this notification.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td></td></tr>
    <tr><td class="paramname">observer</td><td>The observer that originated the change, may be <code>null&lt;/null&gt; </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5146c797c7de71dae87e8045665022e8"></a><!-- doxytag: member="gaia::core::ContentResolver::notifyChange" ref="a5146c797c7de71dae87e8045665022e8" args="(const net::Uri &amp;uri, const storage::ContentObserver *observer, bool syncToNetwork)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a84e1dd8f11f7b45cce0a7e71177c01fb">gaia::core::ContentResolver::notifyChange</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncToNetwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify registered observers that a row was updated. </p>
<p>To register, call <a class="el" href="../../">boolean, android.database.ContentObserver) registerContentObserver()</a>. By default, CursorAdapter objects will get this notification.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td></td></tr>
    <tr><td class="paramname">observer</td><td>The observer that originated the change, may be <code>null&lt;/null&gt; </code></td></tr>
    <tr><td class="paramname">syncToNetwork</td><td><code>If true, attempt to sync the change to the network. </code></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8acd1458b4ee73bbd8a4b7d2841bffe3"></a><!-- doxytag: member="gaia::core::ContentResolver::openFileDescriptorN" ref="a8acd1458b4ee73bbd8a4b7d2841bffe3" args="(const net::Uri &amp;uri, const base::String &amp;mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d9f/classgaia_1_1storage_1_1_parcel_file_descriptor.html">storage::ParcelFileDescriptor</a>* <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a8acd1458b4ee73bbd8a4b7d2841bffe3">gaia::core::ContentResolver::openFileDescriptorN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a raw file descriptor to access data under a "content:" URI. </p>
<p>This is like <a class="el" href="../../">openAssetFileDescriptor(Uri, String)</a>, but uses the underlying <a class="el" href="../../">ContentProvider#openFile</a> ContentProvider.openFile()} method, so will <em>not</em> work with providers that return sub-sections of files. If at all possible, you should use <a class="el" href="../../">openAssetFileDescriptor(Uri, String)</a>. You will receive a FileNotFoundException exception if the provider returns a sub-section of a file.</p>
<h5>Accepts the following URI schemes:</h5>
<ul>
<li>
content (<a class="el" href="../../">SCHEME_CONTENT</a>) </li>
<li>
file (<a class="el" href="../../">SCHEME_FILE</a>) </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The desired URI to open. </td></tr>
    <tr><td class="paramname">mode</td><td>The file mode to use, as per <a class="el" href="../../">ContentProvider.openFile</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a new ParcelFileDescriptor pointing to the file. You own this descriptor and are responsible for closing it when done. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>#openAssetFileDescriptor(Uri, String) </dd></dl>

</div>
</div>
<a class="anchor" id="aca3c27f5fed3f097771edb7bef36e09b"></a><!-- doxytag: member="gaia::core::ContentResolver::openInputStreamN" ref="aca3c27f5fed3f097771edb7bef36e09b" args="(const net::Uri &amp;uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d26/classgaia_1_1storage_1_1_input_stream.html">storage::InputStream</a>* <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aca3c27f5fed3f097771edb7bef36e09b">gaia::core::ContentResolver::openInputStreamN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a stream on to the content associated with a content URI. </p>
<p>If there is no data associated with the URI, FileNotFoundException is thrown.</p>
<h5>Accepts the following URI schemes:</h5>
<ul>
<li>
content (<a class="el" href="../../">SCHEME_CONTENT</a>) </li>
<li>
android.resource (<a class="el" href="../../">SCHEME_ANDROID_RESOURCE</a>) </li>
<li>
file (<a class="el" href="../../">SCHEME_FILE</a>) </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The desired URI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>InputStream </dd></dl>

</div>
</div>
<a class="anchor" id="a9b9b6c20231a55445e06af83ef578d20"></a><!-- doxytag: member="gaia::core::ContentResolver::operator=" ref="a9b9b6c20231a55445e06af83ef578d20" args="(const ContentResolver &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a>&amp; gaia::core::ContentResolver::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html">ContentResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac373b0c95844ac119a69c776556df91e"></a><!-- doxytag: member="gaia::core::ContentResolver::queryN" ref="ac373b0c95844ac119a69c776556df91e" args="(const net::Uri &amp;uri, const base::StringArray *const projection, const base::String *const selection, const base::StringArray *const selectionArgs, const base::String *const sortOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/classgaia_1_1storage_1_1_cursor.html">storage::Cursor</a>* <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ac373b0c95844ac119a69c776556df91e">gaia::core::ContentResolver::queryN</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>selectionArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>sortOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query the given URI, returning a <a class="el" href="../../">Cursor</a> over the result set.  </p>
<p>For best performance, the caller should follow these guidelines: </p>
<ul>
<li>
Provide an explicit projection, to prevent reading data from storage that aren't going to be used. </li>
<li>
Use question mark parameter markers such as 'phone=?' instead of explicit values in the <div class="fragment"><pre class="fragment"> selection 
</pre></div> parameter, so that queries that differ only by those values will be recognized as the same for caching purposes. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URI, using the content:// scheme, for the content to retrieve. </td></tr>
    <tr><td class="paramname">projection</td><td>A list of which columns to return. Passing null will return all columns, which is inefficient. </td></tr>
    <tr><td class="paramname">selection</td><td>A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URI. </td></tr>
    <tr><td class="paramname">selectionArgs</td><td>You may include ?s in selection, which will be replaced by the values from selectionArgs, in the order that they appear in the selection. The values will be bound as Strings. </td></tr>
    <tr><td class="paramname">sortOrder</td><td>How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Cursor object, which is positioned before the first entry, or null </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Cursor NOTE : caller is responsible for deleting returned Cursor object </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3f3f161799ea7a8280f7f092b8ecc2"></a><!-- doxytag: member="gaia::core::ContentResolver::registerContentObserver" ref="a9b3f3f161799ea7a8280f7f092b8ecc2" args="(const net::Uri &amp;uri, bool notifyForDescendents, const storage::ContentObserver &amp;observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a9b3f3f161799ea7a8280f7f092b8ecc2">gaia::core::ContentResolver::registerContentObserver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notifyForDescendents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> &amp;&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an observer class that gets callbacks when data identified by a given content URI changes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URI to watch for changes. This can be a specific row URI, or a base URI for a whole class of content. </td></tr>
    <tr><td class="paramname">notifyForDescendents</td><td>If <code>true</code> changes to URIs beginning with <code>uri</code> will also cause notifications to be sent. If <code>false</code> only changes to the exact URI specified by <em>uri</em> will cause notifications to be sent. If true, than any URI values at or below the specified URI will also trigger a match. </td></tr>
    <tr><td class="paramname">observer</td><td>The object that receives callbacks when changes occur. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a425b781bdaefa347cfffb71586bf97cc" title="Unregisters a change observer.">unregisterContentObserver</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a577715774e12b86018bc8d385eebad"></a><!-- doxytag: member="gaia::core::ContentResolver::removePeriodicSync" ref="a3a577715774e12b86018bc8d385eebad" args="(const accounts::Account &amp;account, const base::String &amp;authority, const Persistence &amp;extras)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a3a577715774e12b86018bc8d385eebad">gaia::core::ContentResolver::removePeriodicSync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> &amp;&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> &amp;&#160;</td>
          <td class="paramname"><em>extras</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a periodic sync. </p>
<p>Has no affect if account, authority and extras don't match an existing periodic sync.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account of the periodic sync to remove </td></tr>
    <tr><td class="paramname">authority</td><td>the provider of the periodic sync to remove </td></tr>
    <tr><td class="paramname">extras</td><td>the extras of the periodic sync to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c04cbca407352bae43ce912fdfc7ceb"></a><!-- doxytag: member="gaia::core::ContentResolver::removeStatusChangeListener" ref="a8c04cbca407352bae43ce912fdfc7ceb" args="(const content::SyncStatusObserver &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a8c04cbca407352bae43ce912fdfc7ceb">gaia::core::ContentResolver::removeStatusChangeListener</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d78/classgaia_1_1content_1_1_sync_status_observer.html">content::SyncStatusObserver</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a previously registered status change listener. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>the callback that was added by <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af0a5b3d993a1a801506dd2320a8e4fa8">addStatusChangeListener</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a158b1a75ca1f1a96c9e1c01113662558"></a><!-- doxytag: member="gaia::core::ContentResolver::requestSync" ref="a158b1a75ca1f1a96c9e1c01113662558" args="(const accounts::Account *account, const base::String &amp;authority, const Persistence *extras)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a158b1a75ca1f1a96c9e1c01113662558">gaia::core::ContentResolver::requestSync</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">Persistence</a> *&#160;</td>
          <td class="paramname"><em>extras</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start an asynchronous sync operation. </p>
<p>If you want to monitor the progress of the sync you may register a SyncObserver. Only values of the following types may be used in the extras bundle: </p>
<ul>
<li>
int </li>
<li>
Long </li>
<li>
bool </li>
<li>
float </li>
<li>
double </li>
<li>
String </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>which account should be synced </td></tr>
    <tr><td class="paramname">authority</td><td>which authority should be synced </td></tr>
    <tr><td class="paramname">extras</td><td>any extras to pass to the SyncAdapter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c74433479367e7339f81a53044de59e"></a><!-- doxytag: member="gaia::core::ContentResolver::setIsSyncable" ref="a2c74433479367e7339f81a53044de59e" args="(const accounts::Account *account, const base::String &amp;authority, int32_t syncable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a2c74433479367e7339f81a53044de59e">gaia::core::ContentResolver::setIsSyncable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>syncable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether this account/provider is syncable. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">syncable</td><td>&gt;0 denotes syncable, 0 means not syncable, &lt;0 means unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a544f510cc4475bdacea195f06867ffe8"></a><!-- doxytag: member="gaia::core::ContentResolver::setMasterSyncAutomatically" ref="a544f510cc4475bdacea195f06867ffe8" args="(bool sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a544f510cc4475bdacea195f06867ffe8">gaia::core::ContentResolver::setMasterSyncAutomatically</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the master auto-sync setting that applies to all the providers and accounts. </p>
<p>If this is false then the per-provider auto-sync setting is ignored.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>the master auto-sync setting that applies to all the providers and accounts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac14226ca4706d1ec89b4dde3ea14b298"></a><!-- doxytag: member="gaia::core::ContentResolver::setSyncAutomatically" ref="ac14226ca4706d1ec89b4dde3ea14b298" args="(const accounts::Account *account, const base::String &amp;authority, bool sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ac14226ca4706d1ec89b4dde3ea14b298">gaia::core::ContentResolver::setSyncAutomatically</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d96/classgaia_1_1accounts_1_1_account.html">accounts::Account</a> *&#160;</td>
          <td class="paramname"><em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether or not the provider is synced when it receives a network tickle. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">account</td><td>the account whose setting we are querying </td></tr>
    <tr><td class="paramname">authority</td><td>the provider whose behavior is being controlled </td></tr>
    <tr><td class="paramname">sync</td><td>true if the provider should be synced when tickles are received for it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecbed902e02593edd7e897178eea2b6c"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS" ref="aecbed902e02593edd7e897178eea2b6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aecbed902e02593edd7e897178eea2b6c">gaia::core::ContentResolver::SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa63ac2074512211cbe559b465ca6b45f"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_DO_NOT_RETRY" ref="aa63ac2074512211cbe559b465ca6b45f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aa63ac2074512211cbe559b465ca6b45f">gaia::core::ContentResolver::SYNC_EXTRAS_DO_NOT_RETRY</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this extra is set to true then the request will not be retried if it fails. </p>

</div>
</div>
<a class="anchor" id="a187efa7e03e216b2ebeea94ecbf73197"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_EXPEDITED" ref="a187efa7e03e216b2ebeea94ecbf73197" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a187efa7e03e216b2ebeea94ecbf73197">gaia::core::ContentResolver::SYNC_EXTRAS_EXPEDITED</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this extra is set to true then the sync will be priority. </p>

</div>
</div>
<a class="anchor" id="a5852d2927a461d2e4bd79a43f21023a2"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_IGNORE_BACKOFF" ref="a5852d2927a461d2e4bd79a43f21023a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a5852d2927a461d2e4bd79a43f21023a2">gaia::core::ContentResolver::SYNC_EXTRAS_IGNORE_BACKOFF</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this extra is set to true then any backoffs for the initial attempt (e.g. </p>
<p>due to retries) are ignored by the sync scheduler. If this request fails and gets rescheduled then the retries will still honor the backoff. </p>

</div>
</div>
<a class="anchor" id="af826522f9a219a0b937144411f8253ec"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_IGNORE_SETTINGS" ref="af826522f9a219a0b937144411f8253ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af826522f9a219a0b937144411f8253ec">gaia::core::ContentResolver::SYNC_EXTRAS_IGNORE_SETTINGS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this extra is set to true then the sync settings (like <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a921ef4b41422fcd9c244fe77745800c4" title="Check if the provider should be synced when a network tickle is received.">getSyncAutomatically()</a>) are ignored by the sync scheduler. </p>

</div>
</div>
<a class="anchor" id="adcb448bdda5aa9f2dd843eb7009e21f6"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_INITIALIZE" ref="adcb448bdda5aa9f2dd843eb7009e21f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#adcb448bdda5aa9f2dd843eb7009e21f6">gaia::core::ContentResolver::SYNC_EXTRAS_INITIALIZE</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af2ef59495a6c4966686ec667a76095dc"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_MANUAL" ref="af2ef59495a6c4966686ec667a76095dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af2ef59495a6c4966686ec667a76095dc">gaia::core::ContentResolver::SYNC_EXTRAS_MANUAL</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting this extra is the equivalent of setting both <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af826522f9a219a0b937144411f8253ec">SYNC_EXTRAS_IGNORE_SETTINGS</a> and <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a5852d2927a461d2e4bd79a43f21023a2">SYNC_EXTRAS_IGNORE_BACKOFF</a>. </p>

</div>
</div>
<a class="anchor" id="a82f7b7b07781bf346e421bc6beff694d"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS" ref="a82f7b7b07781bf346e421bc6beff694d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a82f7b7b07781bf346e421bc6beff694d">gaia::core::ContentResolver::SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af6d1e5f0d99a20b19ecc927ad8cbadfa"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_EXTRAS_UPLOAD" ref="af6d1e5f0d99a20b19ecc927ad8cbadfa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#af6d1e5f0d99a20b19ecc927ad8cbadfa">gaia::core::ContentResolver::SYNC_EXTRAS_UPLOAD</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a425b781bdaefa347cfffb71586bf97cc"></a><!-- doxytag: member="gaia::core::ContentResolver::unregisterContentObserver" ref="a425b781bdaefa347cfffb71586bf97cc" args="(const storage::ContentObserver &amp;observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a425b781bdaefa347cfffb71586bf97cc">gaia::core::ContentResolver::unregisterContentObserver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d5f/classgaia_1_1storage_1_1_content_observer.html">storage::ContentObserver</a> &amp;&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a change observer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The previously registered observer that is no longer needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a9b3f3f161799ea7a8280f7f092b8ecc2" title="Register an observer class that gets callbacks when data identified by a given content URI changes...">registerContentObserver</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad334564ee2db86c6501b6edd48e2a72f"></a><!-- doxytag: member="gaia::core::ContentResolver::update" ref="ad334564ee2db86c6501b6edd48e2a72f" args="(const net::Uri &amp;uri, const content::ContentValues &amp;values, const base::String *const selection, const base::StringArray *const selectionArgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad334564ee2db86c6501b6edd48e2a72f">gaia::core::ContentResolver::update</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>selectionArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update row(s) in a content URI. </p>
<p>If the content provider supports transactions the update will be atomic.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URI to modify. </td></tr>
    <tr><td class="paramname">values</td><td>The new field values. The key is the column name for the field. A null value will remove an existing field value. </td></tr>
    <tr><td class="paramname">selection</td><td>A filter to apply to rows before updating, formatted as an SQL WHERE clause (excluding the WHERE itself). </td></tr>
    <tr><td class="paramname">selectionArgs</td><td>Used to help composite the SQL statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of rows updated. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad64f2dd7c2d1ca5570e25db2a684f2d2"></a><!-- doxytag: member="gaia::core::ContentResolver::mpContentResolverProxy" ref="ad64f2dd7c2d1ca5570e25db2a684f2d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ContentResolverProxy* <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#ad64f2dd7c2d1ca5570e25db2a684f2d2">gaia::core::ContentResolver::mpContentResolverProxy</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="../../d2/d58/_content_resolver_8h_source.html#l00549">549</a> of file <a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06706559d947eecc803956ea5284f018"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_OBSERVER_TYPE_ACTIVE" ref="a06706559d947eecc803956ea5284f018" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a06706559d947eecc803956ea5284f018">gaia::core::ContentResolver::SYNC_OBSERVER_TYPE_ACTIVE</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="../../d2/d58/_content_resolver_8h_source.html#l00090">90</a> of file <a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a>.</p>

</div>
</div>
<a class="anchor" id="aacf8480c42ef9d227e85ad132f24d760"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_OBSERVER_TYPE_PENDING" ref="aacf8480c42ef9d227e85ad132f24d760" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#aacf8480c42ef9d227e85ad132f24d760">gaia::core::ContentResolver::SYNC_OBSERVER_TYPE_PENDING</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="../../d2/d58/_content_resolver_8h_source.html#l00089">89</a> of file <a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89e810efefc5c7b73ef3a7f0ec789946"></a><!-- doxytag: member="gaia::core::ContentResolver::SYNC_OBSERVER_TYPE_SETTINGS" ref="a89e810efefc5c7b73ef3a7f0ec789946" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="../../d6/d55/classgaia_1_1core_1_1_content_resolver.html#a89e810efefc5c7b73ef3a7f0ec789946">gaia::core::ContentResolver::SYNC_OBSERVER_TYPE_SETTINGS</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="../../d2/d58/_content_resolver_8h_source.html#l00088">88</a> of file <a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/vilon_tao/gaia/sdk/include/gaia/core/<a class="el" href="../../d2/d58/_content_resolver_8h_source.html">ContentResolver.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 25 2013 11:23:22 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
