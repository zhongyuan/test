<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gaia::content::ContentProvider Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = '../../open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = '../../closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d9/db5/namespacegaia.html">gaia</a>      </li>
      <li class="navelem"><a class="el" href="../../d1/d94/namespacegaia_1_1content.html">content</a>      </li>
      <li class="navelem"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">gaia::content::ContentProvider Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="gaia::content::ContentProvider" -->
<p>Content providers are one of the primary building blocks of COS applications, providing content to applications.  
 <a href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d3/d8a/_content_provider_8h_source.html">ContentProvider.h</a>&gt;</code></p>

<p><a href="../../d6/dd0/classgaia_1_1content_1_1_content_provider-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a915748e5adfa2e49a2eea3a2ba38bd69">~ContentProvider</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html" title="Content providers are one of the primary building blocks of COS applications, providing content to ap...">ContentProvider</a> destructor.  <a href="#a915748e5adfa2e49a2eea3a2ba38bd69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a610f47211b3d0b2f89bef5381efaad8d">onCreate</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the provider is being started.  <a href="#a610f47211b3d0b2f89bef5381efaad8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../de/de8/classgaia_1_1storage_1_1_cursor.html">storage::Cursor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a8ff8a906bb1d12f96963941b72aa0877">queryN</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const projection, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const selection, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const selectionArgs, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const sortOrder)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a query request from a client in a local process, and returns a Cursor.  <a href="#a8ff8a906bb1d12f96963941b72aa0877"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#acd4628b8298f5400d1d236486f508871">getType</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MIME type of the data at the given URI.  <a href="#acd4628b8298f5400d1d236486f508871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a35c78edee6dfa5f99ddb61d205d8b20e">insert</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">ContentValues</a> &amp;values)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this to insert a new row.  <a href="#a35c78edee6dfa5f99ddb61d205d8b20e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a3afd407fcf6e137a4f06de87dfd0d1ec">bulkInsert</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">gaia::net::Uri</a> &amp;uri, const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">gaia::base::Array</a>&lt; <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">ContentValues</a> &gt; &amp;values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="../../d9/d9f/classgaia_1_1storage_1_1_parcel_file_descriptor.html">gaia::storage::ParcelFileDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#ac004d7847bb7fc88aa46519d9a159c2c">openFileN</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">gaia::net::Uri</a> &amp;uri, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">gaia::base::String</a> &amp;mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#addaaea9cff3e3282c6c2830debdc333b">deleteData</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const selection, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const selectionArgs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A request to delete one or more rows.  <a href="#addaaea9cff3e3282c6c2830debdc333b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a1cf136281e23759fad607d664c330c6e">update</a> (const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;uri, const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &amp;values, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const selection, const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const selectionArgs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a content URI.  <a href="#a1cf136281e23759fad607d664c330c6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../da/d7d/classgaia_1_1content_1_1_content_provider_result_array.html">ContentProviderResultArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a59f0e65b7fdfc074b2ae2ccb2c2d7ffc">applyBatch</a> (const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">base::Array</a>&lt; ContentProviderOperation &gt; &amp;operations)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this to handle requests to perform a batch of operations, or the default implementation will iterate over the operations and call <a class="el" href="../../">ContentProviderOperation#apply</a> on each of them.  <a href="#a59f0e65b7fdfc074b2ae2ccb2c2d7ffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">core::Persistence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a909f73ee216350d52aa28f9c33f78b36">call</a> (const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const method, const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const arg, const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">core::Persistence</a> *const extras)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a provider-defined method.  <a href="#a909f73ee216350d52aa28f9c33f78b36"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a4f92dac89d009054803d910fee17d66b">ContentProvider</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ContentProivder constructor.  <a href="#a4f92dac89d009054803d910fee17d66b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a1b1a94ab74cb9e06e57f63783bce37f1">ContentProvider</a> (const <a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a> &amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#af94b964018fdafc3861d1d526f3d7347">operator=</a> (const <a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a> &amp;o)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Private *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#af7359d7537534af396c0ac0cd1e7bbd9">d</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Content providers are one of the primary building blocks of COS applications, providing content to applications. </p>
<p>They encapsulate data and provide it to applications through the single ContentResolver interface. A content provider is only required if you need to share data between multiple applications. For example, the contacts data is used by multiple applications and must be stored in a content provider. If you don't need to share data amongst multiple applications you can use a database directly via SQLiteDatabase.</p>
<p>When a request is made via a ContentResolver the system inspects the authority of the given URI and passes the request to the content provider registered with the authority. The content provider can interpret the rest of the URI however it wants. The <a class="el" href="../../dc/df8/classgaia_1_1content_1_1_uri_matcher.html">UriMatcher</a> class is helpful for parsing URIs.</p>
<p>The primary methods that need to be implemented are: </p>
<ul>
<li>
<a class="el" href="../../">query</a> which returns data to the caller </li>
<li>
<a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a35c78edee6dfa5f99ddb61d205d8b20e">insert</a> which inserts new data into the content provider </li>
<li>
<a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#a1cf136281e23759fad607d664c330c6e">update</a> which updates existing data in the content provider </li>
<li>
<a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#addaaea9cff3e3282c6c2830debdc333b">deleteData</a> which deletes data from the content provider </li>
<li>
<a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#acd4628b8298f5400d1d236486f508871">getType</a> which returns the MIME type of data in the content provider </li>
</ul>
<p>This class takes care of cross process calls so subclasses don't have to worry about which process a request is coming from.</p>
<p>The following code demonstrates how to use the <a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html" title="Content providers are one of the primary building blocks of COS applications, providing content to ap...">ContentProvider</a></p>
<p>Reading retrieved data </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">private</span> <span class="keywordtype">void</span> getColumnData(Cursor* cur){
     <span class="keywordflow">if</span> (cur-&gt;moveToFirst()) {
         String titlestr;
         <span class="keywordtype">int</span> titleColumn = cur-&gt;getColumnIndex(String(<span class="stringliteral">&quot;title&quot;</span>));

         <span class="keywordflow">do</span> {
              <span class="comment">// Get the field values</span>
              titlestr = cur-&gt;getString(titleColumn);

              <span class="comment">// Do something with the values.</span>
              ...

         } <span class="keywordflow">while</span> (cur-&gt;moveToNext());

     }
 }
</pre></div><p>Modifying <a class="el" href="../../d6/d60/classgaia_1_1content_1_1_data.html" title="The class to provide base infomation for helping to access Data table, which is stored more detail da...">Data</a> </p>
<div class="fragment"><pre class="fragment"> ContentValues* values = <span class="keyword">new</span> ContentValues();
 <span class="comment">// Add Abraham Lincoln to contacts and make him a favorite.* values-&gt;addValue(String(&quot;TITLE&quot;), &quot;Abraham Lincoln&quot;);</span>
 values-&gt;addValue(People.NAME, <span class="stringliteral">&quot;Abraham Lincoln&quot;</span>);
 <span class="comment">// 0 = the new contact is not added to favorites</span>
 values-&gt;put(People.STARRED, 1);

 Uri uri = getContentResolver().insert(People.CONTENT_URI, values);
</pre></div> 
<p>Definition at line <a class="el" href="../../d3/d8a/_content_provider_8h_source.html#l00097">97</a> of file <a class="el" href="../../d3/d8a/_content_provider_8h_source.html">ContentProvider.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a915748e5adfa2e49a2eea3a2ba38bd69"></a><!-- doxytag: member="gaia::content::ContentProvider::~ContentProvider" ref="a915748e5adfa2e49a2eea3a2ba38bd69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual gaia::content::ContentProvider::~ContentProvider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html" title="Content providers are one of the primary building blocks of COS applications, providing content to ap...">ContentProvider</a> destructor. </p>

</div>
</div>
<a class="anchor" id="a4f92dac89d009054803d910fee17d66b"></a><!-- doxytag: member="gaia::content::ContentProvider::ContentProvider" ref="a4f92dac89d009054803d910fee17d66b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gaia::content::ContentProvider::ContentProvider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ContentProivder constructor. </p>

</div>
</div>
<a class="anchor" id="a1b1a94ab74cb9e06e57f63783bce37f1"></a><!-- doxytag: member="gaia::content::ContentProvider::ContentProvider" ref="a1b1a94ab74cb9e06e57f63783bce37f1" args="(const ContentProvider &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gaia::content::ContentProvider::ContentProvider </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a59f0e65b7fdfc074b2ae2ccb2c2d7ffc"></a><!-- doxytag: member="gaia::content::ContentProvider::applyBatch" ref="a59f0e65b7fdfc074b2ae2ccb2c2d7ffc" args="(const base::Array&lt; ContentProviderOperation &gt; &amp;operations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../da/d7d/classgaia_1_1content_1_1_content_provider_result_array.html">ContentProviderResultArray</a> gaia::content::ContentProvider::applyBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">base::Array</a>&lt; ContentProviderOperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>operations</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override this to handle requests to perform a batch of operations, or the default implementation will iterate over the operations and call <a class="el" href="../../">ContentProviderOperation#apply</a> on each of them. </p>
<p>If all calls to <a class="el" href="../../">ContentProviderOperation#apply</a> succeed then a <a class="el" href="../../d5/da9/classgaia_1_1content_1_1_content_provider_result.html">ContentProviderResult</a> array with as many elements as there were operations will be returned. If any of the calls fail, it is up to the implementation how many of the others take effect. This method can be called from multiple threads, as described in</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">operations</td><td>the operations to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the results of the applications </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">OperationApplicationException</td><td>thrown if any operation fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ContentProviderOperation::apply </dd></dl>

</div>
</div>
<a class="anchor" id="a3afd407fcf6e137a4f06de87dfd0d1ec"></a><!-- doxytag: member="gaia::content::ContentProvider::bulkInsert" ref="a3afd407fcf6e137a4f06de87dfd0d1ec" args="(const gaia::net::Uri &amp;uri, const gaia::base::Array&lt; ContentValues &gt; &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t gaia::content::ContentProvider::bulkInsert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">gaia::net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/db0/classgaia_1_1base_1_1_array.html">gaia::base::Array</a>&lt; <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">ContentValues</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a909f73ee216350d52aa28f9c33f78b36"></a><!-- doxytag: member="gaia::content::ContentProvider::call" ref="a909f73ee216350d52aa28f9c33f78b36" args="(const base::String *const method, const base::String *const arg, const core::Persistence *const extras)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">core::Persistence</a> gaia::content::ContentProvider::call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d47/classgaia_1_1core_1_1_persistence.html">core::Persistence</a> *const&#160;</td>
          <td class="paramname"><em>extras</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call a provider-defined method. </p>
<p>This can be used to implement interfaces that are cheaper and/or unnatural for a table-like model.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>method name to call. Opaque to framework, but should not be null. </td></tr>
    <tr><td class="paramname">arg</td><td>provider-defined String argument. May be null. </td></tr>
    <tr><td class="paramname">extras</td><td>provider-defined Bundle argument. May be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>provider-defined return value. May be null. Null is also the default for providers which don't implement any call methods. </dd></dl>

</div>
</div>
<a class="anchor" id="addaaea9cff3e3282c6c2830debdc333b"></a><!-- doxytag: member="gaia::content::ContentProvider::deleteData" ref="addaaea9cff3e3282c6c2830debdc333b" args="(const net::Uri &amp;uri, const base::String *const selection, const base::StringArray *const selectionArgs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t gaia::content::ContentProvider::deleteData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>selectionArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A request to delete one or more rows. </p>
<p>The selection clause is applied when performing the deletion, allowing the operation to affect multiple rows in a directory. This method can be called from multiple threads, as described in <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals: Processes and Threads</a>.</p>
<p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The full URI to query, including a row ID (if a specific record is requested). </td></tr>
    <tr><td class="paramname">selection</td><td>An optional restriction to apply to rows when deleting. </td></tr>
    <tr><td class="paramname">selectionArgs</td><td>The column collection for database table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of rows affected. </dd></dl>

</div>
</div>
<a class="anchor" id="acd4628b8298f5400d1d236486f508871"></a><!-- doxytag: member="gaia::content::ContentProvider::getType" ref="acd4628b8298f5400d1d236486f508871" args="(const net::Uri &amp;uri)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> gaia::content::ContentProvider::getType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the MIME type of the data at the given URI. </p>
<p>This should start with <code>vnd.android.cursor.item</code> for a single record, or <code>vnd.android.cursor.dir/</code> for multiple items. This method can be called from multiple threads, as described in <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals: Processes and Threads</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>the URI to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a MIME type string, or null if there is no type. </dd></dl>

</div>
</div>
<a class="anchor" id="a35c78edee6dfa5f99ddb61d205d8b20e"></a><!-- doxytag: member="gaia::content::ContentProvider::insert" ref="a35c78edee6dfa5f99ddb61d205d8b20e" args="(const net::Uri &amp;uri, const ContentValues &amp;values)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> gaia::content::ContentProvider::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">ContentValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implement this to insert a new row. </p>
<p>This method can be called from multiple threads, as described in <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals: Processes and Threads</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The content:// URI of the insertion request. </td></tr>
    <tr><td class="paramname">values</td><td>A set of column_name/value pairs to add to the database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The URI for the newly inserted item. </dd></dl>

</div>
</div>
<a class="anchor" id="a610f47211b3d0b2f89bef5381efaad8d"></a><!-- doxytag: member="gaia::content::ContentProvider::onCreate" ref="a610f47211b3d0b2f89bef5381efaad8d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gaia::content::ContentProvider::onCreate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when the provider is being started. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the provider was successfully loaded, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac004d7847bb7fc88aa46519d9a159c2c"></a><!-- doxytag: member="gaia::content::ContentProvider::openFileN" ref="ac004d7847bb7fc88aa46519d9a159c2c" args="(const gaia::net::Uri &amp;uri, const gaia::base::String &amp;mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d9/d9f/classgaia_1_1storage_1_1_parcel_file_descriptor.html">gaia::storage::ParcelFileDescriptor</a>* gaia::content::ContentProvider::openFileN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">gaia::net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">gaia::base::String</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af94b964018fdafc3861d1d526f3d7347"></a><!-- doxytag: member="gaia::content::ContentProvider::operator=" ref="af94b964018fdafc3861d1d526f3d7347" args="(const ContentProvider &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a>&amp; gaia::content::ContentProvider::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html">ContentProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ff8a906bb1d12f96963941b72aa0877"></a><!-- doxytag: member="gaia::content::ContentProvider::queryN" ref="a8ff8a906bb1d12f96963941b72aa0877" args="(const net::Uri &amp;uri, const base::StringArray *const projection, const base::String *const selection, const base::StringArray *const selectionArgs, const base::String *const sortOrder)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../de/de8/classgaia_1_1storage_1_1_cursor.html">storage::Cursor</a>* gaia::content::ContentProvider::queryN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>selectionArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>sortOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives a query request from a client in a local process, and returns a Cursor. </p>
<p>This is called internally by the ContentResolver. This method can be called from multiple threads, as described in <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals: Processes and Threads</a>. </p>
<p>Example client call:</p>
<pre>// Request a specific record.
 Cursor managedCursor = managedQuery(
     Contacts.People.CONTENT_URI.addId(2),
     projection,    // Which columns to return.
     null,          // WHERE clause.
     People.NAME + " ASC");   // Sort order.</pre><p> Example implementation:</p>
<pre>// SQLiteQueryBuilder is a helper class that creates the
proper SQL syntax for us.
     SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();</pre><pre>Set the table we're querying.
     qBuilder.setTables(DATABASE_TABLE_NAME);</pre><pre>If the query ends in a specific record number, we're
being asked for a specific record, so set the
WHERE clause in our query.
     if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
     qBuilder.appendWhere("_id=" + uri.getPathLeafId());
     }</pre><pre>Make the query.
     Cursor c = qBuilder.query(mDb,
     projection,
     selection,
     selectionArgs,
     groupBy,
     having,
     sortOrder);
     c.setNotificationUri(getContext().getContentResolver(), uri);
     return c;</pre><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URI to query. This will be the full URI sent by the client; if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value. </td></tr>
    <tr><td class="paramname">projection</td><td>The list of columns to put into the cursor. If null all columns are included. </td></tr>
    <tr><td class="paramname">selection</td><td>A selection criteria to apply when filtering rows. If null then all rows are included. </td></tr>
    <tr><td class="paramname">selectionArgs</td><td>The column collection for database table. </td></tr>
    <tr><td class="paramname">sortOrder</td><td>How the rows in the cursor should be sorted. If null then the provider is free to define the sort order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a Cursor or null. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cf136281e23759fad607d664c330c6e"></a><!-- doxytag: member="gaia::content::ContentProvider::update" ref="a1cf136281e23759fad607d664c330c6e" args="(const net::Uri &amp;uri, const content::ContentValues &amp;values, const base::String *const selection, const base::StringArray *const selectionArgs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t gaia::content::ContentProvider::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dcf/classgaia_1_1net_1_1_uri.html">net::Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d29/classgaia_1_1content_1_1_content_values.html">content::ContentValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/ddb/classgaia_1_1base_1_1_string.html">base::String</a> *const&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/db6/classgaia_1_1base_1_1_string_array.html">base::StringArray</a> *const&#160;</td>
          <td class="paramname"><em>selectionArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update a content URI. </p>
<p>All rows matching the optionally provided selection will have their columns listed as the keys in the values map with the values of those keys. after updating. This method can be called from multiple threads, as described in <a href="{@docRoot}guide/topics/fundamentals.html#procthread">Application Fundamentals: Processes and Threads</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The URI to query. This can potentially have a record ID if this is an update request for a specific record. </td></tr>
    <tr><td class="paramname">values</td><td>A Bundle mapping from column names to new column values (NULL is a valid value). </td></tr>
    <tr><td class="paramname">selection</td><td>An optional filter to match rows to update. </td></tr>
    <tr><td class="paramname">selectionArgs</td><td>The column collection for database table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of rows affected. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af7359d7537534af396c0ac0cd1e7bbd9"></a><!-- doxytag: member="gaia::content::ContentProvider::d" ref="af7359d7537534af396c0ac0cd1e7bbd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Private* <a class="el" href="../../df/d6b/classgaia_1_1content_1_1_content_provider.html#af7359d7537534af396c0ac0cd1e7bbd9">gaia::content::ContentProvider::d</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="../../d3/d8a/_content_provider_8h_source.html#l00329">329</a> of file <a class="el" href="../../d3/d8a/_content_provider_8h_source.html">ContentProvider.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/gpdbuildserver3/Jenkins_Workspace/workspace/BuildGaia2SDKLauncher/sdk/include/gaia/content/<a class="el" href="../../d3/d8a/_content_provider_8h_source.html">ContentProvider.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 12 2013 04:17:39 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
