<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>gaia::core::RemoteCallbackList Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="../../dynsections.js"></script>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d9/db5/namespacegaia.html">gaia</a>      </li>
      <li class="navelem"><a class="el" href="../../db/dfb/namespacegaia_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">gaia::core::RemoteCallbackList Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="gaia::core::RemoteCallbackList" -->
<p>Takes care of the grunt work of maintaining a list of remote interfaces, typically for the use of performing callbacks from a <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a> to its clients.  
 <a href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d37/_remote_callback_list_8h_source.html">RemoteCallbackList.h</a>&gt;</code></p>

<p><a href="../../d2/dec/classgaia_1_1core_1_1_remote_callback_list-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a012a80ca8516b1a4918be2838ad8e13f">RemoteCallbackList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ac109ade2b4c31e03e727ac4b4f0c8e1e">~RemoteCallbackList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#af32971deaad7257b2beb846fd40ca0b8">registerCallback</a> (<a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *callback, void *cookie=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new callback to the list.  <a href="#af32971deaad7257b2beb846fd40ca0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ac3fe3aa959880457c81c20c61a4c4e5d">unregisterCallback</a> (<a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove from the list a callback that was previously added with registerCallback.  <a href="#ac3fe3aa959880457c81c20c61a4c4e5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a0e4ab10d2596091e9981ede92c2ff855">kill</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable this callback list.  <a href="#a0e4ab10d2596091e9981ede92c2ff855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#af91b3a8514878cf540a0dfd01e8bb264">onCallbackDied</a> (<a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *callback, void *cookie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the process hosting a callback in the list has gone away.  <a href="#af91b3a8514878cf540a0dfd01e8bb264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ae3244deb073ec3cd9dabbef605c13d79">beginBroadcast</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to start making calls to the currently registered callbacks.  <a href="#ae3244deb073ec3cd9dabbef605c13d79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#adfa7b76ed42a4762293260b93a4ff3af">getBroadcastItem</a> (int32_t index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an item in the active broadcast that was previously started with beginBroadcast.  <a href="#adfa7b76ed42a4762293260b93a4ff3af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a588aa50485dfecb27f9ff24576499273">getBroadcastCookie</a> (int32_t index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the cookie associated with the item returned by getBroadcastItem.  <a href="#a588aa50485dfecb27f9ff24576499273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a72bd5b929971b71d6f58fb4485f09686">finishBroadcast</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the state of a broadcast previously initiated by calling beginBroadcast.  <a href="#a72bd5b929971b71d6f58fb4485f09686"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a93bbd9ad579e54924a8e3abb0d1aa1cd">getRegisteredCallbackCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered callbacks.  <a href="#a93bbd9ad579e54924a8e3abb0d1aa1cd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#af73762c0fe685afb49916c9222f61ae0">operator=</a> (const <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a> &amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ae3c052d1b8f727929919004d27e74e48">RemoteCallbackList</a> (const <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a> &amp;o)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Impl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#aadad48fdeaf5d7605cb1f7a9496de83f">mpImpl</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Takes care of the grunt work of maintaining a list of remote interfaces, typically for the use of performing callbacks from a <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a> to its clients. </p>
<p>In particular, this:</p>
<ul>
<li>
Keeps track of a set of registered <a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html" title="Base class for Binder interfaces.">IInterface</a> callbacks, taking care to identify them through their underlying unique <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html" title="Base class and low-level protocol for a remotable object.">IBinder</a> (by calling <a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html#a8553850b500fbacd71197ef62dac0795" title="Retrieve the Binder object associated with this interface.">IInterface::asBinder</a>). </li>
<li>
Attaches a <a class="el" href="../../d4/d3e/classgaia_1_1core_1_1_i_binder_1_1_death_recipient.html" title="Interface for receiving a callback when the process hosting an IBinder has gone away.">IBinder::DeathRecipient</a> to each registered interface, so that it can be cleaned out of the list if its process goes away. </li>
<li>
Performs locking of the underlying list of interfaces to deal with multithreaded incoming calls, and a thread-safe way to iterate over a snapshot of the list without holding its lock. </li>
</ul>
<p>To use this class, simply create a single instance along with your delegate, and call its registerCallback and unregisterCallback methods as client register and unregister with your delegate. To call back on to the registered clients, use beginBroadcast, getBroadcastItem, and finishBroadcast.</p>
<p>If a registered callback's process goes away, this class will take care of automatically removing it from the list. If you want to do additional work in this situation, you can create a subclass that implements the onCallbackDied method. </p>

<p>Definition at line <a class="el" href="../../d5/d37/_remote_callback_list_8h_source.html#l00033">33</a> of file <a class="el" href="../../d5/d37/_remote_callback_list_8h_source.html">RemoteCallbackList.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a012a80ca8516b1a4918be2838ad8e13f"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::RemoteCallbackList" ref="a012a80ca8516b1a4918be2838ad8e13f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a012a80ca8516b1a4918be2838ad8e13f">gaia::core::RemoteCallbackList::RemoteCallbackList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac109ade2b4c31e03e727ac4b4f0c8e1e"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::~RemoteCallbackList" ref="ac109ade2b4c31e03e727ac4b4f0c8e1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ac109ade2b4c31e03e727ac4b4f0c8e1e">gaia::core::RemoteCallbackList::~RemoteCallbackList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3c052d1b8f727929919004d27e74e48"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::RemoteCallbackList" ref="ae3c052d1b8f727929919004d27e74e48" args="(const RemoteCallbackList &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a012a80ca8516b1a4918be2838ad8e13f">gaia::core::RemoteCallbackList::RemoteCallbackList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae3244deb073ec3cd9dabbef605c13d79"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::beginBroadcast" ref="ae3244deb073ec3cd9dabbef605c13d79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ae3244deb073ec3cd9dabbef605c13d79">gaia::core::RemoteCallbackList::beginBroadcast</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare to start making calls to the currently registered callbacks. </p>
<p>This creates a copy of the callback list, which you can retrieve items from using getBroadcastItem. Note that only one broadcast can be active at a time, so you must be sure to always call this from the same thread (usually by scheduling with <a class="el" href="../../d8/d3b/classgaia_1_1core_1_1_handler.html" title="This class allows you to send and process Message on main thread.">Handler</a> or do your own synchronization). You must call finishBroadcast when done.</p>
<p>A typical loop delivering a broadcast looks like this:</p>
<pre>
 int32_t i = callbacks.beginBroadcast();
 while (i &gt; 0) {
     i--;
     callbacks.getBroadcastItem(i)-&gt;somethingHappened();
 }
 callbacks.finishBroadcast();</pre><dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of callbacks in the broadcast, to be used with getBroadcastItem to determine the range of indices you can supply. </dd></dl>

</div>
</div>
<a class="anchor" id="a72bd5b929971b71d6f58fb4485f09686"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::finishBroadcast" ref="a72bd5b929971b71d6f58fb4485f09686" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a72bd5b929971b71d6f58fb4485f09686">gaia::core::RemoteCallbackList::finishBroadcast</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up the state of a broadcast previously initiated by calling beginBroadcast. </p>
<p>This must always be called when you are done with a broadcast. </p>

</div>
</div>
<a class="anchor" id="a588aa50485dfecb27f9ff24576499273"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::getBroadcastCookie" ref="a588aa50485dfecb27f9ff24576499273" args="(int32_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a588aa50485dfecb27f9ff24576499273">gaia::core::RemoteCallbackList::getBroadcastCookie</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the cookie associated with the item returned by getBroadcastItem. </p>

</div>
</div>
<a class="anchor" id="adfa7b76ed42a4762293260b93a4ff3af"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::getBroadcastItem" ref="adfa7b76ed42a4762293260b93a4ff3af" args="(int32_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a>* <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#adfa7b76ed42a4762293260b93a4ff3af">gaia::core::RemoteCallbackList::getBroadcastItem</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an item in the active broadcast that was previously started with beginBroadcast. </p>
<p>This can <em>only</em> be called after the broadcast is started, and its data is no longer valid after calling finishBroadcast.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Which of the registered callbacks you would like to retrieve. Ranges from 0 to <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ae3244deb073ec3cd9dabbef605c13d79" title="Prepare to start making calls to the currently registered callbacks.">beginBroadcast()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the callback interface that you can call. This will always be non-null. </dd></dl>

</div>
</div>
<a class="anchor" id="a93bbd9ad579e54924a8e3abb0d1aa1cd"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::getRegisteredCallbackCount" ref="a93bbd9ad579e54924a8e3abb0d1aa1cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a93bbd9ad579e54924a8e3abb0d1aa1cd">gaia::core::RemoteCallbackList::getRegisteredCallbackCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of registered callbacks. </p>
<p>Note that the number of registered callbacks may differ from the value returned by <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ae3244deb073ec3cd9dabbef605c13d79" title="Prepare to start making calls to the currently registered callbacks.">beginBroadcast()</a> since the former returns the number of callbacks registered at the time of the call and the second the number of callback to which the broadcast will be delivered. </p>
<p>This function is useful to decide whether to schedule a broadcast if this requires doing some work which otherwise would not be performed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e4ab10d2596091e9981ede92c2ff855"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::kill" ref="a0e4ab10d2596091e9981ede92c2ff855" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#a0e4ab10d2596091e9981ede92c2ff855">gaia::core::RemoteCallbackList::kill</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable this callback list. </p>
<p>All registered callbacks are unregistered, and the list is disabled so that future calls to registerCallback will fail. This should be used when a <a class="el" href="../../d4/d71/classgaia_1_1core_1_1_delegate.html" title="The Delegate is for creating an extenal thread, in a process differs from a Page process, to process the long-term task.">Delegate</a> is stopping, to prevent clients from registering callbacks after it is stopped. </p>

</div>
</div>
<a class="anchor" id="af91b3a8514878cf540a0dfd01e8bb264"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::onCallbackDied" ref="af91b3a8514878cf540a0dfd01e8bb264" args="(IInterface *callback, void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#af91b3a8514878cf540a0dfd01e8bb264">gaia::core::RemoteCallbackList::onCallbackDied</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when the process hosting a callback in the list has gone away. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback whose process has died. Note that, since its process has died, you can not make any calls on to this interface. You can, however, retrieve its <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html" title="Base class and low-level protocol for a remotable object.">IBinder</a> and compare it with another <a class="el" href="../../d0/d47/classgaia_1_1core_1_1_i_binder.html" title="Base class and low-level protocol for a remotable object.">IBinder</a> to see if it is the same object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie object original provided to registerCallback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af73762c0fe685afb49916c9222f61ae0"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::operator=" ref="af73762c0fe685afb49916c9222f61ae0" args="(const RemoteCallbackList &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a>&amp; gaia::core::RemoteCallbackList::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html">RemoteCallbackList</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af32971deaad7257b2beb846fd40ca0b8"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::registerCallback" ref="af32971deaad7257b2beb846fd40ca0b8" args="(IInterface *callback, void *cookie=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#af32971deaad7257b2beb846fd40ca0b8">gaia::core::RemoteCallbackList::registerCallback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new callback to the list. </p>
<p>This callback will remain in the list until a corresponding call to unregisterCallback or its hosting process goes away. If the callback was already registered (determined by checking to see if the callback-&gt;asBinder() object is already in the list, then it will be left as-is. Registrations are not counted; a single call to unregisterCallback will remove a callback after any number calls to register it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback interface to be added to the list. Must not be NULL.</td></tr>
    <tr><td class="paramname">cookie</td><td>Optional additional data to be associated with this callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the callback was successfully added to the list. Returns false if it was not added, either because kill had previously been called or the callback's process has gone away. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3fe3aa959880457c81c20c61a4c4e5d"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::unregisterCallback" ref="ac3fe3aa959880457c81c20c61a4c4e5d" args="(IInterface *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#ac3fe3aa959880457c81c20c61a4c4e5d">gaia::core::RemoteCallbackList::unregisterCallback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d2a/classgaia_1_1core_1_1_i_interface.html">IInterface</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove from the list a callback that was previously added with registerCallback. </p>
<p>This uses the callback-&gt;asBinder() object to correctly find the previous registration. Registrations are not counted; a single unregisterCallback call will remove a callback after any number calls to registerCallback for it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be removed from the list. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the callback was found and unregistered. Returns false if the given callback was not found on the list. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aadad48fdeaf5d7605cb1f7a9496de83f"></a><!-- doxytag: member="gaia::core::RemoteCallbackList::mpImpl" ref="aadad48fdeaf5d7605cb1f7a9496de83f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Impl* <a class="el" href="../../de/d19/classgaia_1_1core_1_1_remote_callback_list.html#aadad48fdeaf5d7605cb1f7a9496de83f">gaia::core::RemoteCallbackList::mpImpl</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="../../d5/d37/_remote_callback_list_8h_source.html#l00161">161</a> of file <a class="el" href="../../d5/d37/_remote_callback_list_8h_source.html">RemoteCallbackList.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/vilon_tao/gaia/sdk/include/gaia/core/<a class="el" href="../../d5/d37/_remote_callback_list_8h_source.html">RemoteCallbackList.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 25 2013 11:23:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
